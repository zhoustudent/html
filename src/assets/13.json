{"code":0,"success":true,"data":{"has_more":true,"page_token":"9LYIHpUI8I8mHG3r8NUdrD8HofF1bYv9nwWvUXbHmjc=","assessments_list":[{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445585932682788","question_title":"酒店排序","i18n_question_title":"酒店排序","question_skill_list":[{"name":"编码","i18n_name":"编码","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"有这样一个数据结构，保存着酒店信息：\n```javascript\n{\n    hotels: [{\n        id: 1,\n        price: 100,\n        score: 80\n    }, {\n        id: 2,\n        price: 70,\n        score: 90, \n    }, {\n        id: 3,\n        price: 70,\n        score: 95\n    }]\n}\n```\n其中 price 为酒店的价格，score 为酒店评分，按照以下策略给酒店排序：\n先按价格由低到高排序，价格相等时，按评分由高到低排序","i18n_question_description":"有这样一个数据结构，保存着酒店信息：\n```javascript\n{\n    hotels: [{\n        id: 1,\n        price: 100,\n        score: 80\n    }, {\n        id: 2,\n        price: 70,\n        score: 90, \n    }, {\n        id: 3,\n        price: 70,\n        score: 95\n    }]\n}\n```\n其中 price 为酒店的价格，score 为酒店评分，按照以下策略给酒店排序：\n先按价格由低到高排序，价格相等时，按评分由高到低排序","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"javascript\\n\"},{\"insert\":\"function compare(hotel1, hotel2) {\\n\"},{\"insert\":\" if (hotel1.price === hotel2.price) {\\n\"},{\"insert\":\" return hotel1.socre - hotel2.score;\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" return hotel1.price - hotel2.price;\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"hotels.sort(compare);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：\\n\"},{\"insert\":\"2. 3.0分：利用js的sort方法正确写出代码\\n\"},{\"insert\":\"3. 3.5分：不使用js的sort方法，使用其他排序算法正确写出代码\\n\"},{\"insert\":\"4. 4.0分：\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"javascript\\n\"},{\"insert\":\"function compare(hotel1, hotel2) {\\n\"},{\"insert\":\" if (hotel1.price === hotel2.price) {\\n\"},{\"insert\":\" return hotel1.socre - hotel2.score;\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" return hotel1.price - hotel2.price;\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"hotels.sort(compare);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：\\n\"},{\"insert\":\"2. 3.0分：利用js的sort方法正确写出代码\\n\"},{\"insert\":\"3. 3.5分：不使用js的sort方法，使用其他排序算法正确写出代码\\n\"},{\"insert\":\"4. 4.0分：\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916738084","question_title":"HTTP持久连接、Content-Length、Transfer-Encoding的意义和关系，最好可以结合实际场景和代码分析","i18n_question_title":"HTTP持久连接、Content-Length、Transfer-Encoding的意义和关系，最好可以结合实际场景和代码分析","question_skill_list":null,"score":null,"content":null,"question_description":"HTTP持久连接、Content-Length、Transfer-Encoding的意义和关系，最好可以结合实际场景分析，\n如持久连接解决了什么问题，带来了什么问题，Content-Length和Transfer-Encoding的引入是怎么解决的\n如果可以用代码体现更好","i18n_question_description":"HTTP持久连接、Content-Length、Transfer-Encoding的意义和关系，最好可以结合实际场景分析，\n如持久连接解决了什么问题，带来了什么问题，Content-Length和Transfer-Encoding的引入是怎么解决的\n如果可以用代码体现更好","question_answer":"HTTP/1.0 的持久连接机制是后来才引入的，通过 Connection: keep-alive 这个头部来实现，服务端和客户端都可以使用它告诉对方在发送完数据之后不需要断开 TCP 连接，以备后用。HTTP/1.1 则规定所有连接都必须是持久的，除非显式地在头部加上 Connection: close\n以一个NodeJS写的server为例，在响应完成以后destory是没有问题的\n1.如果不加destroy，会出现pengding\n2.如果显示写上Content-Length，同样可以work，因为浏览器可以通过 Content-Length 的长度信息，判断出响应实体已结束\n```\nrequire('net').createServer(function(sock) {\n  sock.on('data', function(data) {\n    sock.write('HTTP/1.1 200 OK\\r\\n');\n\t\tsock.write('Content-Length: 12\\r\\n'); // 如果加一行Content-Length，请求正常结束\n    sock.write('\\r\\n');\n    sock.write('hello world!');\n    sock.destroy(); // 如果去掉这一行，请求会pending\n  });\n}).listen(8804, '127.0.0.1');\n```\n3.Transfer-Encoding:chunked\n在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，报文中的实体需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的 CRLF（\\r\\n），也不包括分块数据结尾的 CRLF。最后一个分块长度值必须为 0，对应的分块数据没有内容，表示实体结束\n```\nrequire('net').createServer(function(sock) {\n  sock.on('data', function(data) {\n    sock.write('HTTP/1.1 200 OK\\r\\n');\n    sock.write('Transfer-Encoding: chunked\\r\\n');\n    sock.write('\\r\\n');\n    sock.write('b\\r\\n');\n    sock.write('01234567890\\r\\n');\n    sock.write('5\\r\\n');\n    sock.write('12345\\r\\n');\n    sock.write('0\\r\\n');\n    sock.write('\\r\\n');\n  });\n}).listen(8804, '127.0.0.1');\n```\n1. 2.5分及以下：不知道这些header的意义\n2. 3.0分：可以正确说出持久连接、Content-Length、Transfer-Encoding用法和意义\n3. 3.5分：在明白意义的基础上，可以明确知晓Transfer-Encoding的判断结束标志，最好可以落地到代码\n4. 4.0分：落地到代码酌情加分","i18n_question_answer":"HTTP/1.0 的持久连接机制是后来才引入的，通过 Connection: keep-alive 这个头部来实现，服务端和客户端都可以使用它告诉对方在发送完数据之后不需要断开 TCP 连接，以备后用。HTTP/1.1 则规定所有连接都必须是持久的，除非显式地在头部加上 Connection: close\n以一个NodeJS写的server为例，在响应完成以后destory是没有问题的\n1.如果不加destroy，会出现pengding\n2.如果显示写上Content-Length，同样可以work，因为浏览器可以通过 Content-Length 的长度信息，判断出响应实体已结束\n```\nrequire('net').createServer(function(sock) {\n  sock.on('data', function(data) {\n    sock.write('HTTP/1.1 200 OK\\r\\n');\n\t\tsock.write('Content-Length: 12\\r\\n'); // 如果加一行Content-Length，请求正常结束\n    sock.write('\\r\\n');\n    sock.write('hello world!');\n    sock.destroy(); // 如果去掉这一行，请求会pending\n  });\n}).listen(8804, '127.0.0.1');\n```\n3.Transfer-Encoding:chunked\n在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，报文中的实体需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的 CRLF（\\r\\n），也不包括分块数据结尾的 CRLF。最后一个分块长度值必须为 0，对应的分块数据没有内容，表示实体结束\n```\nrequire('net').createServer(function(sock) {\n  sock.on('data', function(data) {\n    sock.write('HTTP/1.1 200 OK\\r\\n');\n    sock.write('Transfer-Encoding: chunked\\r\\n');\n    sock.write('\\r\\n');\n    sock.write('b\\r\\n');\n    sock.write('01234567890\\r\\n');\n    sock.write('5\\r\\n');\n    sock.write('12345\\r\\n');\n    sock.write('0\\r\\n');\n    sock.write('\\r\\n');\n  });\n}).listen(8804, '127.0.0.1');\n```\n1. 2.5分及以下：不知道这些header的意义\n2. 3.0分：可以正确说出持久连接、Content-Length、Transfer-Encoding用法和意义\n3. 3.5分：在明白意义的基础上，可以明确知晓Transfer-Encoding的判断结束标志，最好可以落地到代码\n4. 4.0分：落地到代码酌情加分","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916754468","question_title":"页面无刷新文件上传方式","i18n_question_title":"页面无刷新文件上传方式","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"1. 网页里，常用的文件上传方式有哪些？\n2. 哪些方式可以实现页面不刷新就能上传文件？","i18n_question_description":"1. 网页里，常用的文件上传方式有哪些？\n2. 哪些方式可以实现页面不刷新就能上传文件？","question_answer":"1. form表单上传、iframe上传、ajax上传、拖放上传；\n2. 无刷新方式上传：ajax、iframe\n1. 2.5分及以下：不清楚常用的文件上传方式\n2. 3.0分：知道常用的文件上传方式，并能够知道基本原理\n3. 3.5分：两问都能回答上来，并给出详细的解释\n4. 4.0分：","i18n_question_answer":"1. form表单上传、iframe上传、ajax上传、拖放上传；\n2. 无刷新方式上传：ajax、iframe\n1. 2.5分及以下：不清楚常用的文件上传方式\n2. 3.0分：知道常用的文件上传方式，并能够知道基本原理\n3. 3.5分：两问都能回答上来，并给出详细的解释\n4. 4.0分：","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445587425330718","question_title":"用代码实现把字符串转换成base64编码","i18n_question_title":"用代码实现把字符串转换成base64编码","question_skill_list":[{"name":"编码","i18n_name":"编码","nick_name":null,"description":null},{"name":"编程","i18n_name":"编程","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"用代码实现把字符串转换成base64编码","i18n_question_description":"用代码实现把字符串转换成base64编码","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"\\n\"},{\"insert\":\"var base64EncodeChars = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"function base64encode(str){\\n\"},{\"insert\":\" var out, i, len;\\n\"},{\"insert\":\" var c1, c2, c3;\\n\"},{\"insert\":\" len = str.length;\\n\"},{\"insert\":\" i = 0;\\n\"},{\"insert\":\" out = \\\"\\\";\\n\"},{\"insert\":\" while (i < len) {\\n\"},{\"insert\":\" c1 = str.charCodeAt(i++) & 0xff;\\n\"},{\"insert\":\" if (i == len) {\\n\"},{\"insert\":\" out += base64EncodeChars.charAt(c1 >> 2);\\n\"},{\"insert\":\" out += base64EncodeChars.charAt((c1 & 0x3) << 4);\\n\"},{\"insert\":\" out += \\\"==\\\";\\n\"},{\"insert\":\" break;\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" c2 = str.charCodeAt(i++);\\n\"},{\"insert\":\" if (i == len) {\\n\"},{\"insert\":\" out += base64EncodeChars.charAt(c1 >> 2);\\n\"},{\"insert\":\" out += base64EncodeChars.charAt(((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4));\\n\"},{\"insert\":\" out += base64EncodeChars.charAt((c2 & 0xF) << 2);\\n\"},{\"insert\":\" out += \\\"=\\\";\\n\"},{\"insert\":\" break;\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" c3 = str.charCodeAt(i++);\\n\"},{\"insert\":\" out += base64EncodeChars.charAt(c1 >> 2);\\n\"},{\"insert\":\" out += base64EncodeChars.charAt(((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4));\\n\"},{\"insert\":\" out += base64EncodeChars.charAt(((c2 & 0xF) << 2) | ((c3 & 0xC0) >> 6));\\n\"},{\"insert\":\" out += base64EncodeChars.charAt(c3 & 0x3F);\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" return out;\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：没有思路\\n\"},{\"insert\":\"2. 3.0分：了解base64编码过程\\n\"},{\"insert\":\"3. 3.5分：了解base64编码过程，并通过js实现base64编码功能\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"\\n\"},{\"insert\":\"var base64EncodeChars = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"function base64encode(str){\\n\"},{\"insert\":\" var out, i, len;\\n\"},{\"insert\":\" var c1, c2, c3;\\n\"},{\"insert\":\" len = str.length;\\n\"},{\"insert\":\" i = 0;\\n\"},{\"insert\":\" out = \\\"\\\";\\n\"},{\"insert\":\" while (i < len) {\\n\"},{\"insert\":\" c1 = str.charCodeAt(i++) & 0xff;\\n\"},{\"insert\":\" if (i == len) {\\n\"},{\"insert\":\" out += base64EncodeChars.charAt(c1 >> 2);\\n\"},{\"insert\":\" out += base64EncodeChars.charAt((c1 & 0x3) << 4);\\n\"},{\"insert\":\" out += \\\"==\\\";\\n\"},{\"insert\":\" break;\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" c2 = str.charCodeAt(i++);\\n\"},{\"insert\":\" if (i == len) {\\n\"},{\"insert\":\" out += base64EncodeChars.charAt(c1 >> 2);\\n\"},{\"insert\":\" out += base64EncodeChars.charAt(((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4));\\n\"},{\"insert\":\" out += base64EncodeChars.charAt((c2 & 0xF) << 2);\\n\"},{\"insert\":\" out += \\\"=\\\";\\n\"},{\"insert\":\" break;\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" c3 = str.charCodeAt(i++);\\n\"},{\"insert\":\" out += base64EncodeChars.charAt(c1 >> 2);\\n\"},{\"insert\":\" out += base64EncodeChars.charAt(((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4));\\n\"},{\"insert\":\" out += base64EncodeChars.charAt(((c2 & 0xF) << 2) | ((c3 & 0xC0) >> 6));\\n\"},{\"insert\":\" out += base64EncodeChars.charAt(c3 & 0x3F);\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" return out;\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：没有思路\\n\"},{\"insert\":\"2. 3.0分：了解base64编码过程\\n\"},{\"insert\":\"3. 3.5分：了解base64编码过程，并通过js实现base64编码功能\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916672548","question_title":"实现一个bind方法","i18n_question_title":"实现一个bind方法","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"实现一个bind的Polyfill","i18n_question_description":"实现一个bind的Polyfill","question_answer":"考察候选人对apply arguments this的理解\n如果候选人不知道bind方法 可以给予一定的提示 但评分最多给3分\n1. 2.5分及以下：\n写不出来\n2. 3.0分：\n在提示下可以写出bind方法\n3. 3.5分：\n知道bind方法并能完整的写出\n```\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function(oThis) {\n    if (typeof this !== 'function') {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n    }\n    var aArgs   = Array.prototype.slice.call(arguments, 1),\n        fToBind = this,\n        fNOP    = function() {},\n        fBound  = function() {\n          return fToBind.apply(this instanceof fNOP\n                 ? this\n                 : oThis,\n                 aArgs.concat(Array.prototype.slice.call(arguments)));\n        };\n    if (this.prototype) {\n      // Function.prototype doesn't have a prototype property\n      fNOP.prototype = this.prototype; \n    }\n    fBound.prototype = new fNOP();\n    return fBound;\n  };\n}\n```","i18n_question_answer":"考察候选人对apply arguments this的理解\n如果候选人不知道bind方法 可以给予一定的提示 但评分最多给3分\n1. 2.5分及以下：\n写不出来\n2. 3.0分：\n在提示下可以写出bind方法\n3. 3.5分：\n知道bind方法并能完整的写出\n```\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function(oThis) {\n    if (typeof this !== 'function') {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n    }\n    var aArgs   = Array.prototype.slice.call(arguments, 1),\n        fToBind = this,\n        fNOP    = function() {},\n        fBound  = function() {\n          return fToBind.apply(this instanceof fNOP\n                 ? this\n                 : oThis,\n                 aArgs.concat(Array.prototype.slice.call(arguments)));\n        };\n    if (this.prototype) {\n      // Function.prototype doesn't have a prototype property\n      fNOP.prototype = this.prototype; \n    }\n    fBound.prototype = new fNOP();\n    return fBound;\n  };\n}\n```","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916230180","question_title":"Fetch方法请求超时问题代码实现","i18n_question_title":"Fetch方法请求超时问题代码实现","question_skill_list":null,"score":null,"content":null,"question_description":"原生HTML5 API fetch是否有超时机制？如果没有，在服务端没有设定超时的情况下，前端如何用代码实现超时机制？","i18n_question_description":"原生HTML5 API fetch是否有超时机制？如果没有，在服务端没有设定超时的情况下，前端如何用代码实现超时机制？","question_answer":"本题考查的是首先对Fetch方法的基础理解，了解其实Promise为基础。之后，考查的是对Promise中Race方法的应用。\nvar requestUtils = {\n    _fetch: (fetch_promise, timeout) => {\n        var abort_fn = null;\n        //这是一个可以被reject的promise\n        var abort_promise = new Promise(function(resolve, reject) {\n            abort_fn = function() {\n                reject('abort promise');\n            };\n        });\n        //这里使用Promise.race，以最快 resolve 或 reject 的结果来传入后续绑定的回调\n        var abortable_promise = Promise.race([\n            fetch_promise,\n            abort_promise\n        ]);\n        setTimeout(function() {\n            abort_fn();\n        }, timeout);\n        return abortable_promise;\n    }\n};\nexport default requestUtils;\n1. 2.5分及以下：对Promise毫无了解，不知道如何实现。\n2. 3.0分：也许不了解Fetch的使用，引导其为Promise实现。可以用代码实现超时机制，无论是否使用Race方法。\n3. 3.5分：可以实现超时机制，同时，可以用Promise当中比较优雅的Race方法实现。\n4. 4.0分：对Fetch方法有自己的研究，了解其本质是Promise，同时可以用.Race方法优雅的实现超时。同时对Promise中的.then,.catch,.all,.race都有自己的理解","i18n_question_answer":"本题考查的是首先对Fetch方法的基础理解，了解其实Promise为基础。之后，考查的是对Promise中Race方法的应用。\nvar requestUtils = {\n    _fetch: (fetch_promise, timeout) => {\n        var abort_fn = null;\n        //这是一个可以被reject的promise\n        var abort_promise = new Promise(function(resolve, reject) {\n            abort_fn = function() {\n                reject('abort promise');\n            };\n        });\n        //这里使用Promise.race，以最快 resolve 或 reject 的结果来传入后续绑定的回调\n        var abortable_promise = Promise.race([\n            fetch_promise,\n            abort_promise\n        ]);\n        setTimeout(function() {\n            abort_fn();\n        }, timeout);\n        return abortable_promise;\n    }\n};\nexport default requestUtils;\n1. 2.5分及以下：对Promise毫无了解，不知道如何实现。\n2. 3.0分：也许不了解Fetch的使用，引导其为Promise实现。可以用代码实现超时机制，无论是否使用Race方法。\n3. 3.5分：可以实现超时机制，同时，可以用Promise当中比较优雅的Race方法实现。\n4. 4.0分：对Fetch方法有自己的研究，了解其本质是Promise，同时可以用.Race方法优雅的实现超时。同时对Promise中的.then,.catch,.all,.race都有自己的理解","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445585932338724","question_title":"JS编码实现简单模版引擎变量替换","i18n_question_title":"JS编码实现简单模版引擎变量替换","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null},{"name":"字符串","i18n_name":"字符串","nick_name":null,"description":null},{"name":"正则","i18n_name":"正则","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"JS编码实现一个render方法，使得可以这样调用，例如\nconst year = '2017';\nconst month = '09';\nconst day = '21';\nconst str = render('${year}-${month}-${day}');\nconsole.log(str); 输出2017-09-21","i18n_question_description":"JS编码实现一个render方法，使得可以这样调用，例如\nconst year = '2017';\nconst month = '09';\nconst day = '21';\nconst str = render('${year}-${month}-${day}');\nconsole.log(str); 输出2017-09-21","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"\\n\"},{\"insert\":\"// 代码实现\\n\"},{\"insert\":\"function render(tmpl) {\\n\"},{\"insert\":\" const re = /\\\\$\\\\{(.*?)\\\\}/g;\\n\"},{\"insert\":\" const res = tmpl.replace(re, c => {\\n\"},{\"insert\":\" const st = /\\\\$\\\\{(.+?)\\\\}/.exec(c)[1];\\n\"},{\"insert\":\" return eval(st);\\n\"},{\"insert\":\" });\\n\"},{\"insert\":\" return res;\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"// 测试代码\\n\"},{\"insert\":\"const year = '2017';\\n\"},{\"insert\":\"const month = '09';\\n\"},{\"insert\":\"const day = '21';\\n\"},{\"insert\":\"const str = render('${year}-${month}-${day}');\\n\"},{\"insert\":\"console.log(str);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：只能说出是替换，正则或者其他方式\\n\"},{\"insert\":\"2. 3.0分：可以基本实现替换，正确使用replace方法\\n\"},{\"insert\":\"3. 3.5分：正则基本没有问题，replace方法和exec，match等方法都很熟悉\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"\\n\"},{\"insert\":\"// 代码实现\\n\"},{\"insert\":\"function render(tmpl) {\\n\"},{\"insert\":\" const re = /\\\\$\\\\{(.*?)\\\\}/g;\\n\"},{\"insert\":\" const res = tmpl.replace(re, c => {\\n\"},{\"insert\":\" const st = /\\\\$\\\\{(.+?)\\\\}/.exec(c)[1];\\n\"},{\"insert\":\" return eval(st);\\n\"},{\"insert\":\" });\\n\"},{\"insert\":\" return res;\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"// 测试代码\\n\"},{\"insert\":\"const year = '2017';\\n\"},{\"insert\":\"const month = '09';\\n\"},{\"insert\":\"const day = '21';\\n\"},{\"insert\":\"const str = render('${year}-${month}-${day}');\\n\"},{\"insert\":\"console.log(str);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：只能说出是替换，正则或者其他方式\\n\"},{\"insert\":\"2. 3.0分：可以基本实现替换，正确使用replace方法\\n\"},{\"insert\":\"3. 3.5分：正则基本没有问题，replace方法和exec，match等方法都很熟悉\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239915689508","question_title":"js类型转换","i18n_question_title":"js类型转换","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"```javascript\nif（ [] ） \nif ( {} )\nif ( [] == false )\nif ( {} == false )\n```","i18n_question_description":"```javascript\nif（ [] ） \nif ( {} )\nif ( [] == false )\nif ( {} == false )\n```","question_answer":"true\ntrue\ntrue\nfalse\n要求理解本质原因\n1、2是由于是地址引用，3、4是由于==转化,[] == [] 这个好理解. 当两个值都是对象 (引用值) 时, 比较的是两个引用值在内存中是否是同一个对象. 因为此 [] 非彼 [], 虽然同为空数组, 确是两个互不相关的空数组, 自然 == 为 false.[] == ![] 这个要牵涉到 JavaScript 中不同类型 == 比较的规则, 具体是由相关标准定义的. ![] 的值是 false, 此时表达式变为 [] == false, 参照标准, 该比较变成了 [] == ToNumber(false), 即 [] == 0. 这个时候又变成了 ToPrimitive([]) == 0, 即 '' == 0, 接下来就是比较 ToNumber('') == 0, 也就是 0 == 0, 最终结果为 true.[] == {} 同第一个\n能回答正确给 3 分","i18n_question_answer":"true\ntrue\ntrue\nfalse\n要求理解本质原因\n1、2是由于是地址引用，3、4是由于==转化,[] == [] 这个好理解. 当两个值都是对象 (引用值) 时, 比较的是两个引用值在内存中是否是同一个对象. 因为此 [] 非彼 [], 虽然同为空数组, 确是两个互不相关的空数组, 自然 == 为 false.[] == ![] 这个要牵涉到 JavaScript 中不同类型 == 比较的规则, 具体是由相关标准定义的. ![] 的值是 false, 此时表达式变为 [] == false, 参照标准, 该比较变成了 [] == ToNumber(false), 即 [] == 0. 这个时候又变成了 ToPrimitive([]) == 0, 即 '' == 0, 接下来就是比较 ToNumber('') == 0, 也就是 0 == 0, 最终结果为 true.[] == {} 同第一个\n能回答正确给 3 分","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916721700","question_title":"介绍下你所了解的 WebRTC 技术？","i18n_question_title":"介绍下你所了解的 WebRTC 技术？","question_skill_list":null,"score":null,"content":null,"question_description":"如题","i18n_question_description":"如题","question_answer":"WebRTC 技术最核心重要的一点是它可以实现点对点（P2P）的数据传输，而 P2P 最大的一个应用场景是实时视频，\n但是实际上 WebRTC 不仅仅指实时视频，而且可以 P2P 传入任意数据，比如文件等。\n所以，网上有人基于 WebRTC 实现了区块链技术，还有人实现了类似于迅雷、BT 下载之类的底层库。\nWebRTC 建立连接的基本过程就是先到服务器中匹配，匹配成功后可以点对点传输数据。\n（当然这里面需要做很多事情，但是都已有开源库，Google 开源了服务器，浏览器自动做了 NAT 穿透等）\n1. 2.5分及以下：完全不知道，或者基本上不了解，说不出来啥；\n2. 3.0分：基本能够介绍出信息；\n3. 3.5分：完整的介绍出 WebRTC；\n4. 4.0分：曾经实践过；","i18n_question_answer":"WebRTC 技术最核心重要的一点是它可以实现点对点（P2P）的数据传输，而 P2P 最大的一个应用场景是实时视频，\n但是实际上 WebRTC 不仅仅指实时视频，而且可以 P2P 传入任意数据，比如文件等。\n所以，网上有人基于 WebRTC 实现了区块链技术，还有人实现了类似于迅雷、BT 下载之类的底层库。\nWebRTC 建立连接的基本过程就是先到服务器中匹配，匹配成功后可以点对点传输数据。\n（当然这里面需要做很多事情，但是都已有开源库，Google 开源了服务器，浏览器自动做了 NAT 穿透等）\n1. 2.5分及以下：完全不知道，或者基本上不了解，说不出来啥；\n2. 3.0分：基本能够介绍出信息；\n3. 3.5分：完整的介绍出 WebRTC；\n4. 4.0分：曾经实践过；","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916688932","question_title":"本地搭建依赖域名的调试环境","i18n_question_title":"本地搭建依赖域名的调试环境","question_skill_list":[{"name":"工程构建","i18n_name":"工程构建","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"由于有些服务依赖域名进行调试，如一些OpenAPI的域名白名单限制，如何在本地配置以域名形式访问的调试环境（部分还有https的场景）？","i18n_question_description":"由于有些服务依赖域名进行调试，如一些OpenAPI的域名白名单限制，如何在本地配置以域名形式访问的调试环境（部分还有https的场景）？","question_answer":"1.可以借助charles的map remote或者map local进行配置\n2.可以配置本地nginx的server name和upstream，同时修改本地host，需要https的场景知道证书如何配置\n1. 2.5分及以下：没有这方面的配置经验和思路\n2. 3.0分：可以答出最少一种方案，并且明白原理\n3. 3.5分：满足3分基础上，可以讲出一个域名从DNS解析到正向反向代理相关的知识点","i18n_question_answer":"1.可以借助charles的map remote或者map local进行配置\n2.可以配置本地nginx的server name和upstream，同时修改本地host，需要https的场景知道证书如何配置\n1. 2.5分及以下：没有这方面的配置经验和思路\n2. 3.0分：可以答出最少一种方案，并且明白原理\n3. 3.5分：满足3分基础上，可以讲出一个域名从DNS解析到正向反向代理相关的知识点","status_end_time":null,"assessment_create_time":null}],"BaseResp":{"StatusMessage":"SUCCESS","StatusCode":0,"Extra":null}},"message":"OK","special_case_code":0}
