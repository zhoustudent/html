{"code":0,"success":true,"data":{"has_more":true,"page_token":"+Ua6WWSoUcEokE2j/uAdiHdhblLd2STP8j3yWBJxCqQ=","assessments_list":[{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402307602701","question_title":"假设一个网页嵌入一个iframe,如何更改iframe内dom样式？","i18n_question_title":"假设一个网页嵌入一个iframe,如何更改iframe内dom样式？","question_skill_list":[{"name":"可视化","i18n_name":"可视化","nick_name":null,"description":null},{"name":"浏览器","i18n_name":"浏览器","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"假设一个网页嵌入一个iframe,如何更改这个iframe内dom样式","i18n_question_description":"假设一个网页嵌入一个iframe,如何更改这个iframe内dom样式","question_answer":"区分同源和不同源解决方案，同源可以通过document.getElementById('iframeId').contentWindow.document，\n不同源：分iframe的嵌入的页面是否自己可控，可控可以通过postMessage方式更改，iframe页面监听message事件；如果页面不可控，应该无解。\n可以追问iframe有同源策略限制，举个例子说明\n1. 2.5分及以下：iframe的通信没有基本的认识\n2. 3.0分：可以分别根据同源和不同源的情况合理分析\n3. 3.5分：对于实际应用场景可以进行展开，有实际的经验","i18n_question_answer":"区分同源和不同源解决方案，同源可以通过document.getElementById('iframeId').contentWindow.document，\n不同源：分iframe的嵌入的页面是否自己可控，可控可以通过postMessage方式更改，iframe页面监听message事件；如果页面不可控，应该无解。\n可以追问iframe有同源策略限制，举个例子说明\n1. 2.5分及以下：iframe的通信没有基本的认识\n2. 3.0分：可以分别根据同源和不同源的情况合理分析\n3. 3.5分：对于实际应用场景可以进行展开，有实际的经验","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445585932731940","question_title":"实现URL rewrite","i18n_question_title":"实现URL rewrite","question_skill_list":[{"name":"语言基础","i18n_name":"语言基础","nick_name":null,"description":null},{"name":"编码","i18n_name":"编码","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"为字符串扩展一个`rewrite`函数，接受一个正则`pattern`和一个字符串`result`，如果该字符串符合`pattern`，则以`result`对结果进行转义输出。如:\n```js\n'/foo'.rewrite(/^\\/foo/, '/bar') // '/bar'\n'/u1234'.rewrite(/^\\/u(\\d+)/, '/user/$1') // '/user/1234'\n'/i'.rewrite(/^\\/o/, '/o') // null\n```","i18n_question_description":"为字符串扩展一个`rewrite`函数，接受一个正则`pattern`和一个字符串`result`，如果该字符串符合`pattern`，则以`result`对结果进行转义输出。如:\n```js\n'/foo'.rewrite(/^\\/foo/, '/bar') // '/bar'\n'/u1234'.rewrite(/^\\/u(\\d+)/, '/user/$1') // '/user/1234'\n'/i'.rewrite(/^\\/o/, '/o') // null\n```","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"js\\n\"},{\"insert\":\"String.prototype.rewrite = function (pattern, result) {\\n\"},{\"insert\":\" var m = this.match(pattern);\\n\"},{\"insert\":\" if(!m) {\\n\"},{\"insert\":\" return null\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" return result.replace(/\\\\$(\\\\d+)/g, function (_, idx) {\\n\"},{\"insert\":\" return m[idx]\\n\"},{\"insert\":\" });\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：\\n\"},{\"insert\":\"2. 3.0分：\\n\"},{\"insert\":\"3. 3.5分：\\n\"},{\"insert\":\"4. 4.0分：\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"js\\n\"},{\"insert\":\"String.prototype.rewrite = function (pattern, result) {\\n\"},{\"insert\":\" var m = this.match(pattern);\\n\"},{\"insert\":\" if(!m) {\\n\"},{\"insert\":\" return null\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" return result.replace(/\\\\$(\\\\d+)/g, function (_, idx) {\\n\"},{\"insert\":\" return m[idx]\\n\"},{\"insert\":\" });\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：\\n\"},{\"insert\":\"2. 3.0分：\\n\"},{\"insert\":\"3. 3.5分：\\n\"},{\"insert\":\"4. 4.0分：\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058255971730975","question_title":"macro micro 任务队列（async/await版）","i18n_question_title":"macro micro 任务队列（async/await版）","question_skill_list":null,"score":null,"content":null,"question_description":"async function async1() {\n\tconsole.log('async1 start');\n\tawait async2();\n\tconsole.log('async1 end');\n}\nasync function async2() {\n\tconsole.log('async2 start');\n\treturn new Promise((resolve, reject) => {\n\t\tresolve();\n\t\tconsole.log('async2 promise');\n\t})\n}\nconsole.log('script start');\nsetTimeout(function() {\n\tconsole.log('setTimeout');\n}, 0);\t\t\nasync1();\nnew Promise(function(resolve) {\n\tconsole.log('promise1');\n\tresolve();\n}).then(function() {\n\tconsole.log('promise2');\n}).then(function() {\n\tconsole.log('promise3');\n});\nconsole.log('script end');","i18n_question_description":"async function async1() {\n\tconsole.log('async1 start');\n\tawait async2();\n\tconsole.log('async1 end');\n}\nasync function async2() {\n\tconsole.log('async2 start');\n\treturn new Promise((resolve, reject) => {\n\t\tresolve();\n\t\tconsole.log('async2 promise');\n\t})\n}\nconsole.log('script start');\nsetTimeout(function() {\n\tconsole.log('setTimeout');\n}, 0);\t\t\nasync1();\nnew Promise(function(resolve) {\n\tconsole.log('promise1');\n\tresolve();\n}).then(function() {\n\tconsole.log('promise2');\n}).then(function() {\n\tconsole.log('promise3');\n});\nconsole.log('script end');","question_answer":"chrome 和 node 都是以下顺序\n<img src=\"http://tosv.byted.org/obj/ttfe/nodebb/1563171801424-5d2c1bd9fcb820021a6b13dc.png\" width=\"375\" height=\"394.578313253012\" alt=\"\" style=\"margin: auto; display: block;\">\n几个概念：\n同步任务、异步任务 、macrotask 、microtask 、setTimeOut(fn(),0) 、事件循环\n-- 在能清楚以上概念的前提下，可以深入提问什么能生成microtask，什么能生成macrotask：\nmacrotask：\nsetTimeout\nsetInterval\nsetImmediate\nrequestAnimationFrame\nI/O\nUI rendering\nmicrotask:\nprocess.nextTick\nPromises\nObject.observe\nMutationObserver\n2.5 分：不知道概念、知道概念但不清楚具体逻辑\n3分：知道概念并且清楚知道运行逻辑\n3+分：可以举出实际项目中对事件循环的利用，比如性能优化","i18n_question_answer":"chrome 和 node 都是以下顺序\n<img src=\"http://tosv.byted.org/obj/ttfe/nodebb/1563171801424-5d2c1bd9fcb820021a6b13dc.png\" width=\"375\" height=\"394.578313253012\" alt=\"\" style=\"margin: auto; display: block;\">\n几个概念：\n同步任务、异步任务 、macrotask 、microtask 、setTimeOut(fn(),0) 、事件循环\n-- 在能清楚以上概念的前提下，可以深入提问什么能生成microtask，什么能生成macrotask：\nmacrotask：\nsetTimeout\nsetInterval\nsetImmediate\nrequestAnimationFrame\nI/O\nUI rendering\nmicrotask:\nprocess.nextTick\nPromises\nObject.observe\nMutationObserver\n2.5 分：不知道概念、知道概念但不清楚具体逻辑\n3分：知道概念并且清楚知道运行逻辑\n3+分：可以举出实际项目中对事件循环的利用，比如性能优化","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916525092","question_title":"JS代码执行结果判断（if和function知识点）","i18n_question_title":"JS代码执行结果判断（if和function知识点）","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"请说出以下代码的输出：\n```javascript\nvar y = 1;\nif (function f(){}) {\n    y += typeof f;\n}\nconsole.log(y);\n```","i18n_question_description":"请说出以下代码的输出：\n```javascript\nvar y = 1;\nif (function f(){}) {\n    y += typeof f;\n}\nconsole.log(y);\n```","question_answer":"正确的答案应该是 1undefined。\nJavaScript中if语句求值其实使用eval函数，eval(function f(){}) 返回 function f(){} 也就是 true。\n下面我们可以把代码改造下，变成其等效代码。\n```javascript\nvar k = 1;\nif (1) {\n    eval(function foo(){});\n    k += typeof foo;\n}\nconsole.log(k); \n```\n1. 2.5分及以下：\n答案错误\n2. 3.0分：\n能写出正确答案\n3. 3.5分：\n能了解if是执行eval判断，也能说出eval的工作原理\n4. 4.0分：","i18n_question_answer":"正确的答案应该是 1undefined。\nJavaScript中if语句求值其实使用eval函数，eval(function f(){}) 返回 function f(){} 也就是 true。\n下面我们可以把代码改造下，变成其等效代码。\n```javascript\nvar k = 1;\nif (1) {\n    eval(function foo(){});\n    k += typeof foo;\n}\nconsole.log(k); \n```\n1. 2.5分及以下：\n答案错误\n2. 3.0分：\n能写出正确答案\n3. 3.5分：\n能了解if是执行eval判断，也能说出eval的工作原理\n4. 4.0分：","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445600067356190","question_title":"并发请求限制","i18n_question_title":"并发请求限制","question_skill_list":[{"name":"并发","i18n_name":"并发","nick_name":null,"description":null},{"name":"异步","i18n_name":"异步","nick_name":null,"description":null},{"name":"闭包","i18n_name":"闭包","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"【背景】\n一般浏览器会限制并发请求数，微信小程序之前也限制过最多请求不超过10个。\n现在，让我们来实现一下这个功能。\n【问题描述】\n实现这样一个函数scheduler，函数入参为并发最大次数。\n如下最终输出顺序： 2、3、 1、 4\n<blockquote>一开始，1、2两个任务进入队列\n500ms时，2完成，输出2，任务3进队\n800ms时，3完成，输出3，任务4进队\n1000ms时，1完成，输出1\n1200ms时，4完成，输出4\n</blockquote><hr />\n// -----------------mock一些请求\nconst request1 = () =>\n  new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(1);\n    }, 1000);\n  });\nconst request2 = () =>\n  new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(2);\n    }, 500);\n  });\nconst request3 = () =>\n  new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(3);\n    }, 300);\n  });\nconst request4 = () =>\n  new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(4);\n    }, 400);\n  });\n// -----------------最多并发2个请求\nfunction scheduler(max) {\n  // ------你的代码\n}\nconst addRequest = scheduler(2);\naddRequest(request1).then(res => {\n  console.log(res);\n});\naddRequest(request2).then(res => {\n  console.log(res);\n});\naddRequest(request3).then(res => {\n  console.log(res);\n});\naddRequest(request4).then(res => {\n  console.log(res);\n});","i18n_question_description":"【背景】\n一般浏览器会限制并发请求数，微信小程序之前也限制过最多请求不超过10个。\n现在，让我们来实现一下这个功能。\n【问题描述】\n实现这样一个函数scheduler，函数入参为并发最大次数。\n如下最终输出顺序： 2、3、 1、 4\n<blockquote>一开始，1、2两个任务进入队列\n500ms时，2完成，输出2，任务3进队\n800ms时，3完成，输出3，任务4进队\n1000ms时，1完成，输出1\n1200ms时，4完成，输出4\n</blockquote><hr />\n// -----------------mock一些请求\nconst request1 = () =>\n  new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(1);\n    }, 1000);\n  });\nconst request2 = () =>\n  new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(2);\n    }, 500);\n  });\nconst request3 = () =>\n  new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(3);\n    }, 300);\n  });\nconst request4 = () =>\n  new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(4);\n    }, 400);\n  });\n// -----------------最多并发2个请求\nfunction scheduler(max) {\n  // ------你的代码\n}\nconst addRequest = scheduler(2);\naddRequest(request1).then(res => {\n  console.log(res);\n});\naddRequest(request2).then(res => {\n  console.log(res);\n});\naddRequest(request3).then(res => {\n  console.log(res);\n});\naddRequest(request4).then(res => {\n  console.log(res);\n});","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"\\n\"},{\"insert\":\"function scheduler(max) {\\n\"},{\"insert\":\"  // 你的代码\\n\"},{\"insert\":\"  const queue = [];\\n\"},{\"insert\":\"  let runCount = 0;\\n\"},{\"insert\":\"  const run = () =&gt; {\\n\"},{\"insert\":\"    if (runCount &lt; max &amp;&amp; queue.length &gt; 0) {\\n\"},{\"insert\":\"      runCount++;\\n\"},{\"insert\":\"      const { task, resolve, reject } = queue.shift();\\n\"},{\"insert\":\"      task()\\n\"},{\"insert\":\"        .then(res =&gt; {\\n\"},{\"insert\":\"          resolve(res);\\n\"},{\"insert\":\"          runCount--;\\n\"},{\"insert\":\"          run();\\n\"},{\"insert\":\"        })\\n\"},{\"insert\":\"        .catch(err =&gt; {\\n\"},{\"insert\":\"          reject(err);\\n\"},{\"insert\":\"          runCount--;\\n\"},{\"insert\":\"          run();\\n\"},{\"insert\":\"        });\\n\"},{\"insert\":\"    }\\n\"},{\"insert\":\"  };\\n\"},{\"insert\":\"  return function addRequest(task) {\\n\"},{\"insert\":\"    return new Promise((resolve, reject) =&gt; {\\n\"},{\"insert\":\"      queue.push({\\n\"},{\"insert\":\"        resolve,\\n\"},{\"insert\":\"        reject,\\n\"},{\"insert\":\"        task,\\n\"},{\"insert\":\"      });\\n\"},{\"insert\":\"      run();\\n\"},{\"insert\":\"    });\\n\"},{\"insert\":\"  };\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"思路正确：3分\\n\"},{\"insert\":\"能写出来：3分+\\n\"},{\"insert\":\"能考虑异常case或指出题目中不足，能考虑更完美情况，例如task的入参: 3.5分\\n\"},{\"insert\":\"\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"\\n\"},{\"insert\":\"function scheduler(max) {\\n\"},{\"insert\":\"  // 你的代码\\n\"},{\"insert\":\"  const queue = [];\\n\"},{\"insert\":\"  let runCount = 0;\\n\"},{\"insert\":\"  const run = () =&gt; {\\n\"},{\"insert\":\"    if (runCount &lt; max &amp;&amp; queue.length &gt; 0) {\\n\"},{\"insert\":\"      runCount++;\\n\"},{\"insert\":\"      const { task, resolve, reject } = queue.shift();\\n\"},{\"insert\":\"      task()\\n\"},{\"insert\":\"        .then(res =&gt; {\\n\"},{\"insert\":\"          resolve(res);\\n\"},{\"insert\":\"          runCount--;\\n\"},{\"insert\":\"          run();\\n\"},{\"insert\":\"        })\\n\"},{\"insert\":\"        .catch(err =&gt; {\\n\"},{\"insert\":\"          reject(err);\\n\"},{\"insert\":\"          runCount--;\\n\"},{\"insert\":\"          run();\\n\"},{\"insert\":\"        });\\n\"},{\"insert\":\"    }\\n\"},{\"insert\":\"  };\\n\"},{\"insert\":\"  return function addRequest(task) {\\n\"},{\"insert\":\"    return new Promise((resolve, reject) =&gt; {\\n\"},{\"insert\":\"      queue.push({\\n\"},{\"insert\":\"        resolve,\\n\"},{\"insert\":\"        reject,\\n\"},{\"insert\":\"        task,\\n\"},{\"insert\":\"      });\\n\"},{\"insert\":\"      run();\\n\"},{\"insert\":\"    });\\n\"},{\"insert\":\"  };\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"思路正确：3分\\n\"},{\"insert\":\"能写出来：3分+\\n\"},{\"insert\":\"能考虑异常case或指出题目中不足，能考虑更完美情况，例如task的入参: 3.5分\\n\"},{\"insert\":\"\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916656164","question_title":"js prototype概念考察","i18n_question_title":"js prototype概念考察","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"给出下面的代码，问输出是什么？\n```js\nFunction.prototype.f = function() {};\nObject.prototype.o = function() {};\nfunction Factory() {}\nvar car = new Factory();\nconsole.log(car.f);\nconsole.log(car.o);\n```","i18n_question_description":"给出下面的代码，问输出是什么？\n```js\nFunction.prototype.f = function() {};\nObject.prototype.o = function() {};\nfunction Factory() {}\nvar car = new Factory();\nconsole.log(car.f);\nconsole.log(car.o);\n```","question_answer":"输出：\nundefined\nfunction() {}\n解释：\n* Js中一切皆为对象\n* prototype是每个function定义时自带的属性\n* Function是一个用于构造函数类型(function)变量的类，与之相似有的Object或String、Number等\n* prototype和length是每一个函数类型自带的两个属性，而其它非函数类型并没有\n* 除了prototype之外，Js中的所有对象（undefined、null等特殊情况除外）都有一个内置的`[[Prototype]]`属性，指向它“父类”的prototype，这个内置属性在ECMA标准中并没有给出明确的获取方式，但是许多Js的实现（如Node、大部分浏览器等）都提供了一个__proto__属性来指代这一`[[Prototype]]`\n```js\ntypeof Object // function\ntypeof Function // function\nFunction.prototype // [Function: Empty]\n```\n1. 2.5分及以下：不了解js的原型相关概念\n2. 3.0分：知道答案，并给出原因\n3. 3.5分：给出原因，并深入的讲解原型相关知识\n4. 4.0分：","i18n_question_answer":"输出：\nundefined\nfunction() {}\n解释：\n* Js中一切皆为对象\n* prototype是每个function定义时自带的属性\n* Function是一个用于构造函数类型(function)变量的类，与之相似有的Object或String、Number等\n* prototype和length是每一个函数类型自带的两个属性，而其它非函数类型并没有\n* 除了prototype之外，Js中的所有对象（undefined、null等特殊情况除外）都有一个内置的`[[Prototype]]`属性，指向它“父类”的prototype，这个内置属性在ECMA标准中并没有给出明确的获取方式，但是许多Js的实现（如Node、大部分浏览器等）都提供了一个__proto__属性来指代这一`[[Prototype]]`\n```js\ntypeof Object // function\ntypeof Function // function\nFunction.prototype // [Function: Empty]\n```\n1. 2.5分及以下：不了解js的原型相关概念\n2. 3.0分：知道答案，并给出原因\n3. 3.5分：给出原因，并深入的讲解原型相关知识\n4. 4.0分：","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445591128458765","question_title":"实现一个函数，可以给Vue组件添加多个beforeRouteEnter钩子","i18n_question_title":"实现一个函数，可以给Vue组件添加多个beforeRouteEnter钩子","question_skill_list":[{"name":"编码","i18n_name":"编码","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"Vue项目中引入Vue-router后，Vue组件会有一个新的生命周期钩子' beforeRouteEnter', 现在我们要实现一个compose函数，它的功能是可以给Vue组件在执行原有' beforeRouteEnter'之前执行一个函数，该函数签名和' beforeRouteEnter'钩子相同。（相当于给Vue组件再添加了一个' beforeRouteEnter'钩子）比如：\n有一个Vue单文件组件Comp实现如下，\nlet Comp = {\n beforeRouteEnter (to, from, next) {\n  next((vm) => {\n   console.log(1)\n  })\n }\n}\n要添加的新函数实现如下：\nfunction func (to, from, next) {\n next((vm) => {\n  console.log(2)\n })\n}\n//调用compose函数后，每当路由进入Comp前都会依次输出 “2 和1.”\nComp.beforeRouteEnter = compose(Comp.beforeRouteEnter, func)\n补全代码：\nfunction compose (beforeRouteEnter, func) {\n//...\n}","i18n_question_description":"Vue项目中引入Vue-router后，Vue组件会有一个新的生命周期钩子' beforeRouteEnter', 现在我们要实现一个compose函数，它的功能是可以给Vue组件在执行原有' beforeRouteEnter'之前执行一个函数，该函数签名和' beforeRouteEnter'钩子相同。（相当于给Vue组件再添加了一个' beforeRouteEnter'钩子）比如：\n有一个Vue单文件组件Comp实现如下，\nlet Comp = {\n beforeRouteEnter (to, from, next) {\n  next((vm) => {\n   console.log(1)\n  })\n }\n}\n要添加的新函数实现如下：\nfunction func (to, from, next) {\n next((vm) => {\n  console.log(2)\n })\n}\n//调用compose函数后，每当路由进入Comp前都会依次输出 “2 和1.”\nComp.beforeRouteEnter = compose(Comp.beforeRouteEnter, func)\n补全代码：\nfunction compose (beforeRouteEnter, func) {\n//...\n}","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"\\n\"},{\"insert\":\"function compose (beforeRouteEnter, func) {\\n\"},{\"insert\":\"  return function (to, from, next) {\\n\"},{\"insert\":\"    if (beforeRouteEnter) {\\n\"},{\"insert\":\"      let promise = new Promise((resolve) =&gt; {\\n\"},{\"insert\":\"        func(to, from, (cb) =&gt; {\\n\"},{\"insert\":\"          resolve(cb)\\n\"},{\"insert\":\"        })\\n\"},{\"insert\":\"      })\\n\"},{\"insert\":\"      promise.then((callback) =&gt; {\\n\"},{\"insert\":\"        beforeRouteEnter(to, from, (cb) =&gt; {\\n\"},{\"insert\":\"          next((vm) =&gt; {\\n\"},{\"insert\":\"            callback &amp;&amp; callback(vm)\\n\"},{\"insert\":\"            cb &amp;&amp; cb(vm)\\n\"},{\"insert\":\"          })\\n\"},{\"insert\":\"        })\\n\"},{\"insert\":\"      })\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"    } else {\\n\"},{\"insert\":\"      func(to, from, next)\\n\"},{\"insert\":\"    }\\n\"},{\"insert\":\"  }\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"实现二\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"const compose = (beforeRouteEnter, func) =&gt; (to, from, next) =&gt; {\\n\"},{\"insert\":\"  func(to, from, (cb1) =&gt; {\\n\"},{\"insert\":\"    beforeRouteEnter(to, from, (cb2) =&gt; {\\n\"},{\"insert\":\"      next((vm) =&gt; {\\n\"},{\"insert\":\"        cb1(vm);\\n\"},{\"insert\":\"        cb2(vm);\\n\"},{\"insert\":\"      })\\n\"},{\"insert\":\"    })\\n\"},{\"insert\":\"  })\\n\"},{\"insert\":\"};\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"\\n\"},{\"insert\":\"function compose (beforeRouteEnter, func) {\\n\"},{\"insert\":\"  return function (to, from, next) {\\n\"},{\"insert\":\"    if (beforeRouteEnter) {\\n\"},{\"insert\":\"      let promise = new Promise((resolve) =&gt; {\\n\"},{\"insert\":\"        func(to, from, (cb) =&gt; {\\n\"},{\"insert\":\"          resolve(cb)\\n\"},{\"insert\":\"        })\\n\"},{\"insert\":\"      })\\n\"},{\"insert\":\"      promise.then((callback) =&gt; {\\n\"},{\"insert\":\"        beforeRouteEnter(to, from, (cb) =&gt; {\\n\"},{\"insert\":\"          next((vm) =&gt; {\\n\"},{\"insert\":\"            callback &amp;&amp; callback(vm)\\n\"},{\"insert\":\"            cb &amp;&amp; cb(vm)\\n\"},{\"insert\":\"          })\\n\"},{\"insert\":\"        })\\n\"},{\"insert\":\"      })\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"    } else {\\n\"},{\"insert\":\"      func(to, from, next)\\n\"},{\"insert\":\"    }\\n\"},{\"insert\":\"  }\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"实现二\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"const compose = (beforeRouteEnter, func) =&gt; (to, from, next) =&gt; {\\n\"},{\"insert\":\"  func(to, from, (cb1) =&gt; {\\n\"},{\"insert\":\"    beforeRouteEnter(to, from, (cb2) =&gt; {\\n\"},{\"insert\":\"      next((vm) =&gt; {\\n\"},{\"insert\":\"        cb1(vm);\\n\"},{\"insert\":\"        cb2(vm);\\n\"},{\"insert\":\"      })\\n\"},{\"insert\":\"    })\\n\"},{\"insert\":\"  })\\n\"},{\"insert\":\"};\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916574244","question_title":"css中z-index属性考察","i18n_question_title":"css中z-index属性考察","question_skill_list":[{"name":"CSS","i18n_name":"CSS","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"给出下面一段代码：\n```html\n  <div style=\"height: 150px;\">                \n    <div class=\"box1\" style=\"z-index:1;position:absolute;background-color:#16a085;height:150px;width:150px;\"></div>\n    <div class=\"box2\" style=\"z-index:999;color:#ff0000;\">\n      测试文本..测试文本...测试文本...\n    </div>\n  </div>\n```\n问：box1在box2上面，还是box2在box1上面？","i18n_question_description":"给出下面一段代码：\n```html\n  <div style=\"height: 150px;\">                \n    <div class=\"box1\" style=\"z-index:1;position:absolute;background-color:#16a085;height:150px;width:150px;\"></div>\n    <div class=\"box2\" style=\"z-index:999;color:#ff0000;\">\n      测试文本..测试文本...测试文本...\n    </div>\n  </div>\n```\n问：box1在box2上面，还是box2在box1上面？","question_answer":"答案：box1在box2上面\n考察是否对`z-index`生效条件了解，概念：\nz-index只对定位元素有效，这里的定位指：absolute、relative、fixed和inherit，其中inherit取决于父元素，如果父元素没有设置定位(absolute、relative、fixed)则z-index无效，注意低版本IE浏览器不支持这个值\n1. 2.5分及以下：不知道答案\n2. 3.0分：知道答案，并给出解释\n3. 3.5分：除了给出答案，还了解z-index属性其他注意点，浏览器兼容性等\n4. 4.0分：","i18n_question_answer":"答案：box1在box2上面\n考察是否对`z-index`生效条件了解，概念：\nz-index只对定位元素有效，这里的定位指：absolute、relative、fixed和inherit，其中inherit取决于父元素，如果父元素没有设置定位(absolute、relative、fixed)则z-index无效，注意低版本IE浏览器不支持这个值\n1. 2.5分及以下：不知道答案\n2. 3.0分：知道答案，并给出解释\n3. 3.5分：除了给出答案，还了解z-index属性其他注意点，浏览器兼容性等\n4. 4.0分：","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916033572","question_title":"HTTP缓存协议","i18n_question_title":"HTTP缓存协议","question_skill_list":[{"name":"HTML","i18n_name":"HTML","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"在HTTP响应Header中，Cache-control的常规值有哪些？","i18n_question_description":"在HTTP响应Header中，Cache-control的常规值有哪些？","question_answer":"（1）、public max-age \n    缓存的有效时间\n（2）、no-store \n     浏览器不保存实体\n（3）、reload \n     强制发送请求\n（4）、no-cache \n   浏览器保存内容实体，在重新发请求时，不使用缓存的内容实体。\n（5）、force-cache \n    强制使用缓存\n（6）、only-if-cached \n    表示只接受是被缓存的内容\n3分 \n \n能够了解常规的  no-cache ， public max-age， force-cache的意义\n3.5分\n能够了解各个值的意义，并且知道使用场景\n4分\n能够从浏览器源码层面，了解缓存的意义：\n\tenum RequestCache { \"default\", \"no-store\", \"reload\", \"no-cache\", \"force-cache\", \"only-if-cached\" };\n // Always use preloads.\n    if (existingResource->isPreloaded())\n        return Use;\n    // We can find resources that are being validated from cache only when validation is just successfully completing.\n    if (existingResource->validationCompleting())\n        return Use;\n    ASSERT(!existingResource->validationInProgress());\n    auto cachePolicy = this->cachePolicy(type, request.url());\n    // Validate the redirect chain.\n    bool cachePolicyIsHistoryBuffer = cachePolicy == CachePolicyHistoryBuffer;\n    if (!existingResource->redirectChainAllowsReuse(cachePolicyIsHistoryBuffer ? ReuseExpiredRedirection : DoNotReuseExpiredRedirection)) {\n        LOG(ResourceLoading, \"CachedResourceLoader::determineRevalidationPolicy reloading due to not cached or expired redirections.\");\n        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonRedirectChainKey());\n        return Reload;\n    }\n    // CachePolicyHistoryBuffer uses the cache except if this is a main resource with \"cache-control: no-store\".\n    if (cachePolicyIsHistoryBuffer) {\n        // FIXME: Ignoring \"cache-control: no-cache\" for sub-resources on history navigation but not the main\n        // resource is inconsistent. We should probably harmonize this.\n        if (!existingResource->response().cacheControlContainsNoStore() || type != CachedResource::MainResource)\n            return Use;\n    }\n    // Don't reuse resources with Cache-control: no-store.\n    if (existingResource->response().cacheControlContainsNoStore()) {\n        LOG(ResourceLoading, \"CachedResourceLoader::determineRevalidationPolicy reloading due to Cache-control: no-store.\");\n        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonNoStoreKey());\n        return Reload;\n    }\n    // If credentials were sent with the previous request and won't be\n    // with this one, or vice versa, re-fetch the resource.\n    //\n    // This helps with the case where the server sends back\n    // \"Access-Control-Allow-Origin: *\" all the time, but some of the\n    // client's requests are made without CORS and some with.\n    if (existingResource->resourceRequest().allowCookies() != request.allowCookies()) {\n        LOG(ResourceLoading, \"CachedResourceLoader::determineRevalidationPolicy reloading due to difference in credentials settings.\");\n        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonCredentialSettingsKey());\n        return Reload;\n    }\n    // During the initial load, avoid loading the same resource multiple times for a single document, even if the cache policies would tell us to.\n    if (document() && !document()->loadEventFinished() && m_validatedURLs.contains(existingResource->url()))\n        return Use;\n    // CachePolicyReload always reloads\n    if (cachePolicy == CachePolicyReload) {\n        LOG(ResourceLoading, \"CachedResourceLoader::determineRevalidationPolicy reloading due to CachePolicyReload.\");\n        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonReloadKey());\n        return Reload;\n    }\n    \n    // We'll try to reload the resource if it failed last time.\n    if (existingResource->errorOccurred()) {\n        LOG(ResourceLoading, \"CachedResourceLoader::determineRevalidationPolicye reloading due to resource being in the error state\");\n        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonErrorKey());\n        return Reload;\n    }\n    if (existingResource->isLoading()) {\n        // Do not use cached main resources that are still loading because sharing\n        // loading CachedResources in this case causes issues with regards to cancellation.\n        // If one of the DocumentLoader clients decides to cancel the load, then the load\n        // would be cancelled for all other DocumentLoaders as well.\n        if (type == CachedResource::Type::MainResource)\n            return Reload;\n        // For cached subresources that are still loading we ignore the cache policy.\n        return Use;\n    }\n    auto revalidationDecision = existingResource->makeRevalidationDecision(cachePolicy);\n    logResourceRevalidationDecision(revalidationDecision, frame());\n    // Check if the cache headers requires us to revalidate (cache expiration for example).\n    if (revalidationDecision != CachedResource::RevalidationDecision::No) {\n        // See if the resource has usable ETag or Last-modified headers.\n        if (existingResource->canUseCacheValidator())\n            return Revalidate;\n        \n        // No, must reload.\n        LOG(ResourceLoading, \"CachedResourceLoader::determineRevalidationPolicy reloading due to missing cache validators.\");\n        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonMustRevalidateNoValidatorKey());\n        return Reload;\n    }\n    return Use;\n}","i18n_question_answer":"（1）、public max-age \n    缓存的有效时间\n（2）、no-store \n     浏览器不保存实体\n（3）、reload \n     强制发送请求\n（4）、no-cache \n   浏览器保存内容实体，在重新发请求时，不使用缓存的内容实体。\n（5）、force-cache \n    强制使用缓存\n（6）、only-if-cached \n    表示只接受是被缓存的内容\n3分 \n \n能够了解常规的  no-cache ， public max-age， force-cache的意义\n3.5分\n能够了解各个值的意义，并且知道使用场景\n4分\n能够从浏览器源码层面，了解缓存的意义：\n\tenum RequestCache { \"default\", \"no-store\", \"reload\", \"no-cache\", \"force-cache\", \"only-if-cached\" };\n // Always use preloads.\n    if (existingResource->isPreloaded())\n        return Use;\n    // We can find resources that are being validated from cache only when validation is just successfully completing.\n    if (existingResource->validationCompleting())\n        return Use;\n    ASSERT(!existingResource->validationInProgress());\n    auto cachePolicy = this->cachePolicy(type, request.url());\n    // Validate the redirect chain.\n    bool cachePolicyIsHistoryBuffer = cachePolicy == CachePolicyHistoryBuffer;\n    if (!existingResource->redirectChainAllowsReuse(cachePolicyIsHistoryBuffer ? ReuseExpiredRedirection : DoNotReuseExpiredRedirection)) {\n        LOG(ResourceLoading, \"CachedResourceLoader::determineRevalidationPolicy reloading due to not cached or expired redirections.\");\n        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonRedirectChainKey());\n        return Reload;\n    }\n    // CachePolicyHistoryBuffer uses the cache except if this is a main resource with \"cache-control: no-store\".\n    if (cachePolicyIsHistoryBuffer) {\n        // FIXME: Ignoring \"cache-control: no-cache\" for sub-resources on history navigation but not the main\n        // resource is inconsistent. We should probably harmonize this.\n        if (!existingResource->response().cacheControlContainsNoStore() || type != CachedResource::MainResource)\n            return Use;\n    }\n    // Don't reuse resources with Cache-control: no-store.\n    if (existingResource->response().cacheControlContainsNoStore()) {\n        LOG(ResourceLoading, \"CachedResourceLoader::determineRevalidationPolicy reloading due to Cache-control: no-store.\");\n        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonNoStoreKey());\n        return Reload;\n    }\n    // If credentials were sent with the previous request and won't be\n    // with this one, or vice versa, re-fetch the resource.\n    //\n    // This helps with the case where the server sends back\n    // \"Access-Control-Allow-Origin: *\" all the time, but some of the\n    // client's requests are made without CORS and some with.\n    if (existingResource->resourceRequest().allowCookies() != request.allowCookies()) {\n        LOG(ResourceLoading, \"CachedResourceLoader::determineRevalidationPolicy reloading due to difference in credentials settings.\");\n        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonCredentialSettingsKey());\n        return Reload;\n    }\n    // During the initial load, avoid loading the same resource multiple times for a single document, even if the cache policies would tell us to.\n    if (document() && !document()->loadEventFinished() && m_validatedURLs.contains(existingResource->url()))\n        return Use;\n    // CachePolicyReload always reloads\n    if (cachePolicy == CachePolicyReload) {\n        LOG(ResourceLoading, \"CachedResourceLoader::determineRevalidationPolicy reloading due to CachePolicyReload.\");\n        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonReloadKey());\n        return Reload;\n    }\n    \n    // We'll try to reload the resource if it failed last time.\n    if (existingResource->errorOccurred()) {\n        LOG(ResourceLoading, \"CachedResourceLoader::determineRevalidationPolicye reloading due to resource being in the error state\");\n        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonErrorKey());\n        return Reload;\n    }\n    if (existingResource->isLoading()) {\n        // Do not use cached main resources that are still loading because sharing\n        // loading CachedResources in this case causes issues with regards to cancellation.\n        // If one of the DocumentLoader clients decides to cancel the load, then the load\n        // would be cancelled for all other DocumentLoaders as well.\n        if (type == CachedResource::Type::MainResource)\n            return Reload;\n        // For cached subresources that are still loading we ignore the cache policy.\n        return Use;\n    }\n    auto revalidationDecision = existingResource->makeRevalidationDecision(cachePolicy);\n    logResourceRevalidationDecision(revalidationDecision, frame());\n    // Check if the cache headers requires us to revalidate (cache expiration for example).\n    if (revalidationDecision != CachedResource::RevalidationDecision::No) {\n        // See if the resource has usable ETag or Last-modified headers.\n        if (existingResource->canUseCacheValidator())\n            return Revalidate;\n        \n        // No, must reload.\n        LOG(ResourceLoading, \"CachedResourceLoader::determineRevalidationPolicy reloading due to missing cache validators.\");\n        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonMustRevalidateNoValidatorKey());\n        return Reload;\n    }\n    return Use;\n}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239915968036","question_title":"js数组API用法","i18n_question_title":"js数组API用法","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"[ [3,2,1].reduce(Math.pow);\n [].reduce(Math.pow) ];","i18n_question_description":"[ [3,2,1].reduce(Math.pow);\n [].reduce(Math.pow) ];","question_answer":"reduce接受两个参数, 一个回调, 一个初始值.\n回调函数接受四个参数 previousValue, currentValue, currentIndex, array\n需要注意的是如果数组为空切没有给定初始值，会抛出异常\n所以第二个表达式会报异常. 第一个表达式等价于 Math.pow(3, 2) => 9; Math.pow(9, 1) =>9\n9;\nError；\n3分：能答对两个问题得3分，基础题目","i18n_question_answer":"reduce接受两个参数, 一个回调, 一个初始值.\n回调函数接受四个参数 previousValue, currentValue, currentIndex, array\n需要注意的是如果数组为空切没有给定初始值，会抛出异常\n所以第二个表达式会报异常. 第一个表达式等价于 Math.pow(3, 2) => 9; Math.pow(9, 1) =>9\n9;\nError；\n3分：能答对两个问题得3分，基础题目","status_end_time":null,"assessment_create_time":null}],"BaseResp":{"StatusMessage":"SUCCESS","StatusCode":0,"Extra":null}},"message":"OK","special_case_code":0}
