{"code":0,"success":true,"data":{"has_more":true,"page_token":"nZHhudpI+ffQsJWCB9DviFySvrJwnf31R9v9a8i0bYg=","assessments_list":[{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445585932830244","question_title":"版本号排序","i18n_question_title":"版本号排序","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null},{"name":"排序","i18n_name":"排序","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"versions是一个项目的版本号列表，因多人维护，不规则\n``` javascript\nvar versions=['1.45.0','1.5','6','3.3.3.3.3.3.3']\n```\n要求从小到大排序，注意'1.45'比'1.5'大\n``` javascript\nvar sorted=['1.5','1.45.0','3.3.3.3.3.3','6']\n```","i18n_question_description":"versions是一个项目的版本号列表，因多人维护，不规则\n``` javascript\nvar versions=['1.45.0','1.5','6','3.3.3.3.3.3.3']\n```\n要求从小到大排序，注意'1.45'比'1.5'大\n``` javascript\nvar sorted=['1.5','1.45.0','3.3.3.3.3.3','6']\n```","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"javascript\\n\"},{\"insert\":\"function sortVersion(arr) {\\n\"},{\"insert\":\" return arr.sort((a, b) => {\\n\"},{\"insert\":\" const arrA = a.split('.')\\n\"},{\"insert\":\" const arrB = b.split('.')\\n\"},{\"insert\":\" for (let i = 0; i < arrA.length; i++) {\\n\"},{\"insert\":\" if (arrA[i] === undefined) {\\n\"},{\"insert\":\" return -1\\n\"},{\"insert\":\" } else if (arrB[i] === undefined) {\\n\"},{\"insert\":\" return 1\\n\"},{\"insert\":\" } else if (parseInt(arrA[i]) === parseInt(arrB[i])) {\\n\"},{\"insert\":\" continue\\n\"},{\"insert\":\" } else {\\n\"},{\"insert\":\" return parseInt(arrA[i]) > parseInt(arrB[i])\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" })\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：\\n\"},{\"insert\":\"2. 3.0分：完成、代码冗余、逻辑不清晰\\n\"},{\"insert\":\"3. 3.5分：完成、代码优良\\n\"},{\"insert\":\"4. 4.0分：完成、更好算法\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"javascript\\n\"},{\"insert\":\"function sortVersion(arr) {\\n\"},{\"insert\":\" return arr.sort((a, b) => {\\n\"},{\"insert\":\" const arrA = a.split('.')\\n\"},{\"insert\":\" const arrB = b.split('.')\\n\"},{\"insert\":\" for (let i = 0; i < arrA.length; i++) {\\n\"},{\"insert\":\" if (arrA[i] === undefined) {\\n\"},{\"insert\":\" return -1\\n\"},{\"insert\":\" } else if (arrB[i] === undefined) {\\n\"},{\"insert\":\" return 1\\n\"},{\"insert\":\" } else if (parseInt(arrA[i]) === parseInt(arrB[i])) {\\n\"},{\"insert\":\" continue\\n\"},{\"insert\":\" } else {\\n\"},{\"insert\":\" return parseInt(arrA[i]) > parseInt(arrB[i])\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" })\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：\\n\"},{\"insert\":\"2. 3.0分：完成、代码冗余、逻辑不清晰\\n\"},{\"insert\":\"3. 3.5分：完成、代码优良\\n\"},{\"insert\":\"4. 4.0分：完成、更好算法\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445595297187364","question_title":"多行文本处理与分割","i18n_question_title":"多行文本处理与分割","question_skill_list":[{"name":"es","i18n_name":"es","nick_name":null,"description":null},{"name":"编码","i18n_name":"编码","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"把下面的纯文整理为3行4列（复杂点可以把\"2dd\"中加空格）：\n```\naaaa \"dd\"    f g;fd分\n1    \"2dd\" \t113 512  \n   q 'w' er,-/ g  \n```","i18n_question_description":"把下面的纯文整理为3行4列（复杂点可以把\"2dd\"中加空格）：\n```\naaaa \"dd\"    f g;fd分\n1    \"2dd\" \t113 512  \n   q 'w' er,-/ g  \n```","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"javascript\\n\"},{\"insert\":\"str.split('\\\\n').map(row=>row.trim().split(/\\\\s+/g))\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：没有完成\\n\"},{\"insert\":\"2. 3.0分：完成\\n\"},{\"insert\":\"3. 3.5分：完成，代码清晰\\n\"},{\"insert\":\"4. 4.0分：代码简短、正则使用\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"javascript\\n\"},{\"insert\":\"str.split('\\\\n').map(row=>row.trim().split(/\\\\s+/g))\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：没有完成\\n\"},{\"insert\":\"2. 3.0分：完成\\n\"},{\"insert\":\"3. 3.5分：完成，代码清晰\\n\"},{\"insert\":\"4. 4.0分：代码简短、正则使用\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402307569933","question_title":"请问JAVAScript有几种类型的值，并绘制对应的内存图","i18n_question_title":"请问JAVAScript有几种类型的值，并绘制对应的内存图","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"主要是区分原始数据类型和引用类型以及对应内存的存储位置。","i18n_question_description":"主要是区分原始数据类型和引用类型以及对应内存的存储位置。","question_answer":"- 原始数据类型（Undefined，Null，Boolean，Number、String）-- 栈\n- 引用数据类型（对象、数组和函数）-- 堆\n- 两种类型的区别是：存储位置不同：\n- 原始数据类型是直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据；\n- 引用数据类型存储在堆(heap)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能；\n- 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。\n- 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n1. 2.5分及以下：不了解存在原始数据类型和引用数据类型两种类型\n2. 3.0分：了解两种类型以及分别包含哪些数据类型。\n3. 3.5分：能够清晰的阐述区分两种类型对应的内存位置以及原因","i18n_question_answer":"- 原始数据类型（Undefined，Null，Boolean，Number、String）-- 栈\n- 引用数据类型（对象、数组和函数）-- 堆\n- 两种类型的区别是：存储位置不同：\n- 原始数据类型是直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据；\n- 引用数据类型存储在堆(heap)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能；\n- 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。\n- 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n1. 2.5分及以下：不了解存在原始数据类型和引用数据类型两种类型\n2. 3.0分：了解两种类型以及分别包含哪些数据类型。\n3. 3.5分：能够清晰的阐述区分两种类型对应的内存位置以及原因","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445587425445406","question_title":"合并两个有序数组","i18n_question_title":"合并两个有序数组","question_skill_list":[{"name":"编码","i18n_name":"编码","nick_name":null,"description":null},{"name":"编程","i18n_name":"编程","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"合并两个有序数组","i18n_question_description":"合并两个有序数组","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"\\n\"},{\"insert\":\"function mergeSortedArray(a, b){\\n\"},{\"insert\":\" var merged = [], \\n\"},{\"insert\":\" aElm = a[0],\\n\"},{\"insert\":\" bElm = b[0],\\n\"},{\"insert\":\" i = 1,\\n\"},{\"insert\":\" j = 1;\\n\"},{\"insert\":\" if(a.length ==0)\\n\"},{\"insert\":\" return b;\\n\"},{\"insert\":\" if(b.length ==0)\\n\"},{\"insert\":\" return a;\\n\"},{\"insert\":\" while(aElm || bElm){\\n\"},{\"insert\":\" if((aElm && !bElm) || aElm < bElm){\\n\"},{\"insert\":\" merged.push(aElm);\\n\"},{\"insert\":\" aElm = a[i++];\\n\"},{\"insert\":\" } \\n\"},{\"insert\":\" else {\\n\"},{\"insert\":\" merged.push(bElm);\\n\"},{\"insert\":\" bElm = b[j++];\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" return merged;\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"验证\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"mergeSortedArray([2,5,6,9], [1,2,3,29]);\\n\"},{\"insert\":\"结果 [1, 2, 2, 3, 5, 6, 9, 29]\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：没有思路或结果不正确\\n\"},{\"insert\":\"2. 3.0分：结果正确\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"\\n\"},{\"insert\":\"function mergeSortedArray(a, b){\\n\"},{\"insert\":\" var merged = [], \\n\"},{\"insert\":\" aElm = a[0],\\n\"},{\"insert\":\" bElm = b[0],\\n\"},{\"insert\":\" i = 1,\\n\"},{\"insert\":\" j = 1;\\n\"},{\"insert\":\" if(a.length ==0)\\n\"},{\"insert\":\" return b;\\n\"},{\"insert\":\" if(b.length ==0)\\n\"},{\"insert\":\" return a;\\n\"},{\"insert\":\" while(aElm || bElm){\\n\"},{\"insert\":\" if((aElm && !bElm) || aElm < bElm){\\n\"},{\"insert\":\" merged.push(aElm);\\n\"},{\"insert\":\" aElm = a[i++];\\n\"},{\"insert\":\" } \\n\"},{\"insert\":\" else {\\n\"},{\"insert\":\" merged.push(bElm);\\n\"},{\"insert\":\" bElm = b[j++];\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" return merged;\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"验证\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"mergeSortedArray([2,5,6,9], [1,2,3,29]);\\n\"},{\"insert\":\"结果 [1, 2, 2, 3, 5, 6, 9, 29]\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：没有思路或结果不正确\\n\"},{\"insert\":\"2. 3.0分：结果正确\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445585932715556","question_title":"JS如何解析字节流？","i18n_question_title":"JS如何解析字节流？","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null},{"name":"es","i18n_name":"es","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"JS在处理二进制方面有哪些接口和对象可供使用？例如XHR2允许服务器返回二进制数据，如何设置以接收返回的二进制类型？应该如何解析？","i18n_question_description":"JS在处理二进制方面有哪些接口和对象可供使用？例如XHR2允许服务器返回二进制数据，如何设置以接收返回的二进制类型？应该如何解析？","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"ArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"// DataView\\n\"},{\"insert\":\"const buf = new ArrayBuffer(32);\\n\"},{\"insert\":\"const dataView = new DataView(buf);\\n\"},{\"insert\":\"dataView.getUint8(0) // 0\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"const buffer = new ArrayBuffer(12);\\n\"},{\"insert\":\"// TypedArray\\n\"},{\"insert\":\"const x1 = new Int32Array(buffer);\\n\"},{\"insert\":\"x1[0] = 1;\\n\"},{\"insert\":\"const x2 = new Uint8Array(buffer);\\n\"},{\"insert\":\"x2[0] = 2;\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"x1[0] // 2\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"应用场景 XHR2中\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"let xhr = new XMLHttpRequest();\\n\"},{\"insert\":\"xhr.open('GET', someUrl);\\n\"},{\"insert\":\"xhr.responseType = 'arraybuffer';\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"xhr.onload = function () {\\n\"},{\"insert\":\" let arrayBuffer = xhr.response;\\n\"},{\"insert\":\" // ···\\n\"},{\"insert\":\"};\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"xhr.send();\\n\"},{\"insert\":\"// 如果知道传回来的是 32 位整数\\n\"},{\"insert\":\"xhr.onreadystatechange = function () {\\n\"},{\"insert\":\" if (req.readyState === 4 ) {\\n\"},{\"insert\":\" const arrayResponse = xhr.response;\\n\"},{\"insert\":\" const dataView = new DataView(arrayResponse);\\n\"},{\"insert\":\" const ints = new Uint32Array(dataView.byteLength / 4);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" xhrDiv.style.backgroundColor = \\\"#00FF00\\\";\\n\"},{\"insert\":\" xhrDiv.innerText = \\\"Array is \\\" + ints.length + \\\"uints long\\\";\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"Fetch API\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"fetch(url)\\n\"},{\"insert\":\".then(function(response){\\n\"},{\"insert\":\" return response.arrayBuffer()\\n\"},{\"insert\":\"})\\n\"},{\"insert\":\".then(function(arrayBuffer){\\n\"},{\"insert\":\" // ...\\n\"},{\"insert\":\"});\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"此外还有Canvas, Websocket, File API等使用场景\\n\"},{\"insert\":\"1. 2.5分及以下：不知道arrayBuffer的基本用法和操作\\n\"},{\"insert\":\"2. 3.0分：可以讲出arrayBuffer的一些基础用法和使用场景\\n\"},{\"insert\":\"3. 3.5分：对于字节流的操作有一定的使用经验，可以结合场景写出基本用法\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"ArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"// DataView\\n\"},{\"insert\":\"const buf = new ArrayBuffer(32);\\n\"},{\"insert\":\"const dataView = new DataView(buf);\\n\"},{\"insert\":\"dataView.getUint8(0) // 0\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"const buffer = new ArrayBuffer(12);\\n\"},{\"insert\":\"// TypedArray\\n\"},{\"insert\":\"const x1 = new Int32Array(buffer);\\n\"},{\"insert\":\"x1[0] = 1;\\n\"},{\"insert\":\"const x2 = new Uint8Array(buffer);\\n\"},{\"insert\":\"x2[0] = 2;\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"x1[0] // 2\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"应用场景 XHR2中\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"let xhr = new XMLHttpRequest();\\n\"},{\"insert\":\"xhr.open('GET', someUrl);\\n\"},{\"insert\":\"xhr.responseType = 'arraybuffer';\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"xhr.onload = function () {\\n\"},{\"insert\":\" let arrayBuffer = xhr.response;\\n\"},{\"insert\":\" // ···\\n\"},{\"insert\":\"};\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"xhr.send();\\n\"},{\"insert\":\"// 如果知道传回来的是 32 位整数\\n\"},{\"insert\":\"xhr.onreadystatechange = function () {\\n\"},{\"insert\":\" if (req.readyState === 4 ) {\\n\"},{\"insert\":\" const arrayResponse = xhr.response;\\n\"},{\"insert\":\" const dataView = new DataView(arrayResponse);\\n\"},{\"insert\":\" const ints = new Uint32Array(dataView.byteLength / 4);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" xhrDiv.style.backgroundColor = \\\"#00FF00\\\";\\n\"},{\"insert\":\" xhrDiv.innerText = \\\"Array is \\\" + ints.length + \\\"uints long\\\";\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"Fetch API\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"fetch(url)\\n\"},{\"insert\":\".then(function(response){\\n\"},{\"insert\":\" return response.arrayBuffer()\\n\"},{\"insert\":\"})\\n\"},{\"insert\":\".then(function(arrayBuffer){\\n\"},{\"insert\":\" // ...\\n\"},{\"insert\":\"});\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"此外还有Canvas, Websocket, File API等使用场景\\n\"},{\"insert\":\"1. 2.5分及以下：不知道arrayBuffer的基本用法和操作\\n\"},{\"insert\":\"2. 3.0分：可以讲出arrayBuffer的一些基础用法和使用场景\\n\"},{\"insert\":\"3. 3.5分：对于字节流的操作有一定的使用经验，可以结合场景写出基本用法\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445596262549022","question_title":"JavaScript 连续赋值操作","i18n_question_title":"JavaScript 连续赋值操作","question_skill_list":[{"name":"语言基础","i18n_name":"语言基础","nick_name":null,"description":null},{"name":"编码","i18n_name":"编码","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"var a = {\n    k1: 'v1'\n};\nvar b = a;\na.k3 = a = {\n  k2: 'v2'\n};\nconsole.log(a);\nconsole.log(b);","i18n_question_description":"var a = {\n    k1: 'v1'\n};\nvar b = a;\na.k3 = a = {\n  k2: 'v2'\n};\nconsole.log(a);\nconsole.log(b);","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"a => {k2: \\\"v2\\\"}\\n\"},{\"insert\":\"b => {k1: \\\"v1\\\", k3: {k2: \\\"v2\\\"}}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"本题目考察 JavaScript 在进行连续赋值操作时：\\n\"},{\"insert\":\" 1. 从左至右计算引用；\\n\"},{\"insert\":\" 2. 从右至左进行赋值。\\n\"},{\"insert\":\"设计本题一共5分。\\n\"},{\"insert\":\"a 和 b 的值均正确可得 5 分。\\n\"},{\"insert\":\"其中之一正确可得 4 分。\\n\"},{\"insert\":\"均不正确不得分。\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"a => {k2: \\\"v2\\\"}\\n\"},{\"insert\":\"b => {k1: \\\"v1\\\", k3: {k2: \\\"v2\\\"}}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"本题目考察 JavaScript 在进行连续赋值操作时：\\n\"},{\"insert\":\" 1. 从左至右计算引用；\\n\"},{\"insert\":\" 2. 从右至左进行赋值。\\n\"},{\"insert\":\"设计本题一共5分。\\n\"},{\"insert\":\"a 和 b 的值均正确可得 5 分。\\n\"},{\"insert\":\"其中之一正确可得 4 分。\\n\"},{\"insert\":\"均不正确不得分。\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916394020","question_title":"ES6 import的原理","i18n_question_title":"ES6 import的原理","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"请描述ES6 import的原理以及与commonjs的require的区别","i18n_question_description":"请描述ES6 import的原理以及与commonjs的require的区别","question_answer":"CommonJS模块的是一个值的拷贝，而ES6模块输出的是值的引用。\nES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。\nCommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\nES6模块的运行机制与CommonJS不一样，它遇到模块加载命令import时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，ES6的输入有点像Unix系统的“符号连接”，原始值变了，import输入的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\n1. 2.5分及以下：\n不能说出原理以及区别\n2. 3.0分：\n能说出es6模块的原理与commonjs的区别\n3. 3.5分：\n4. 4.0分：","i18n_question_answer":"CommonJS模块的是一个值的拷贝，而ES6模块输出的是值的引用。\nES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。\nCommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\nES6模块的运行机制与CommonJS不一样，它遇到模块加载命令import时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，ES6的输入有点像Unix系统的“符号连接”，原始值变了，import输入的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\n1. 2.5分及以下：\n不能说出原理以及区别\n2. 3.0分：\n能说出es6模块的原理与commonjs的区别\n3. 3.5分：\n4. 4.0分：","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239917098532","question_title":"移动端如何解决点透问题，以及click的300ms左右延迟？","i18n_question_title":"移动端如何解决点透问题，以及click的300ms左右延迟？","question_skill_list":[{"name":"移动端","i18n_name":"移动端","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"移动端如何解决点透问题，以及click的300ms左右延迟？","i18n_question_description":"移动端如何解决点透问题，以及click的300ms左右延迟？","question_answer":"1.zepto的方案\na.因为js标准本不支持tap事件，所以zepto tap是touchstart与touchend模拟而出；\nb.zepto在初始化时便给document绑定touch事件，在我们点击时根据event参数获得当前元素，并会保存点下和离开时候的鼠标位置\nc.根据当前元素鼠标移动范围判断是否为类点击事件，如果是便触发已经注册好的tap事件\n2.fastclick的方案\na.将事件绑定到你传的元素（一般是document.body）\nb.在touchstart和touchend后（会手动获取当前点击el），如果是类click事件便手动触发了dom元素的click事件\n所以click事件在touchend便被触发，整个响应速度就起来了，触发实际与zepto tap一样\n3.为什么zepto会点透而fastclick不会呢？\n原因是zepto的代码里面有个settimeout，而就算在这个代码里面执行e.preventDefault()也不会有用；\n这就是根本区别，因为settimeout会将优先级较低；有了定期器，当代码执行到setTimeout的时候， 就会把这个代码放到JS的引擎的最后面 \n而我们代码会马上检测到e.preventDefault，一旦加入settimeout，e.preventDefault便不会生效，这是zepto点透的根本原因\n1. 2.5分及以下：没有解决过点透，和click的延迟或简单粗暴提出touchstart直接代替click等\n2. 3.0分：用过tap和fastclick，了解基本用法和解决什么问题\n3. 3.5分：对于tap和fastclick的原理很清楚","i18n_question_answer":"1.zepto的方案\na.因为js标准本不支持tap事件，所以zepto tap是touchstart与touchend模拟而出；\nb.zepto在初始化时便给document绑定touch事件，在我们点击时根据event参数获得当前元素，并会保存点下和离开时候的鼠标位置\nc.根据当前元素鼠标移动范围判断是否为类点击事件，如果是便触发已经注册好的tap事件\n2.fastclick的方案\na.将事件绑定到你传的元素（一般是document.body）\nb.在touchstart和touchend后（会手动获取当前点击el），如果是类click事件便手动触发了dom元素的click事件\n所以click事件在touchend便被触发，整个响应速度就起来了，触发实际与zepto tap一样\n3.为什么zepto会点透而fastclick不会呢？\n原因是zepto的代码里面有个settimeout，而就算在这个代码里面执行e.preventDefault()也不会有用；\n这就是根本区别，因为settimeout会将优先级较低；有了定期器，当代码执行到setTimeout的时候， 就会把这个代码放到JS的引擎的最后面 \n而我们代码会马上检测到e.preventDefault，一旦加入settimeout，e.preventDefault便不会生效，这是zepto点透的根本原因\n1. 2.5分及以下：没有解决过点透，和click的延迟或简单粗暴提出touchstart直接代替click等\n2. 3.0分：用过tap和fastclick，了解基本用法和解决什么问题\n3. 3.5分：对于tap和fastclick的原理很清楚","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445596262843934","question_title":"NodeJS实现简单的HTTP代理和隧道代理","i18n_question_title":"NodeJS实现简单的HTTP代理和隧道代理","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"Web代理一般包括普通的HTTP代理和隧道代理，谈谈理解。\nNodeJS实现一个简单的HTTP代理，如在本地 8888 端口开启 HTTP 代理服务，修改浏览器的 HTTP 代理为 127.0.0.1:8888 后再访问 HTTP 网站，代理可以正常工作\n对隧道代理了解多少，能否实现？","i18n_question_description":"Web代理一般包括普通的HTTP代理和隧道代理，谈谈理解。\nNodeJS实现一个简单的HTTP代理，如在本地 8888 端口开启 HTTP 代理服务，修改浏览器的 HTTP 代理为 127.0.0.1:8888 后再访问 HTTP 网站，代理可以正常工作\n对隧道代理了解多少，能否实现？","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"http普通代理：HTTP 客户端向代理发送请求报文，代理服务器需要正确地处理请求和连接（例如正确处理 Connection: keep-alive），同时向服务器发送请求，并将收到的响应转发给客户端。\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"// http 普通代理\\n\"},{\"insert\":\"const http = require('http');\\n\"},{\"insert\":\"const net = require('net');\\n\"},{\"insert\":\"const url = require('url');\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"function request(cReq, cRes) {\\n\"},{\"insert\":\" const u = url.parse(cReq.url);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" const options = {\\n\"},{\"insert\":\" hostname: u.hostname,\\n\"},{\"insert\":\" port: u.port || 80,\\n\"},{\"insert\":\" path: u.path,\\n\"},{\"insert\":\" method: cReq.method,\\n\"},{\"insert\":\" headers: cReq.headers\\n\"},{\"insert\":\" };\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" const pReq = http.request(options, pRes => {\\n\"},{\"insert\":\" cRes.writeHead(pRes.statusCode, pRes.headers);\\n\"},{\"insert\":\" pRes.pipe(cRes);\\n\"},{\"insert\":\" }).on('error', function(e) {\\n\"},{\"insert\":\" cRes.end();\\n\"},{\"insert\":\" });\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" cReq.pipe(pReq);\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"http.createServer().on('request', request).listen(8888, '0.0.0.0');\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"隧道代理：HTTP 客户端通过 CONNECT 方法请求隧道代理创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"const http = require('http');\\n\"},{\"insert\":\"const net = require('net');\\n\"},{\"insert\":\"const url = require('url');\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"function connect(cReq, cSock) {\\n\"},{\"insert\":\" const u = url.parse('http://' + cReq.url);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" const pSock = net.connect(u.port, u.hostname, function() {\\n\"},{\"insert\":\" cSock.write('HTTP/1.1 200 Connection Established\\\\r\\\\n\\\\r\\\\n');\\n\"},{\"insert\":\" pSock.pipe(cSock);\\n\"},{\"insert\":\" }).on('error', function(e) {\\n\"},{\"insert\":\" cSock.end();\\n\"},{\"insert\":\" });\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" cSock.pipe(pSock);\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"http.createServer().on('connect', connect).listen(8888, '0.0.0.0');\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"合二为一\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"const http = require('http');\\n\"},{\"insert\":\"const net = require('net');\\n\"},{\"insert\":\"const url = require('url');\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"function request(cReq, cRes) {\\n\"},{\"insert\":\" const u = url.parse(cReq.url);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" const options = {\\n\"},{\"insert\":\" hostname: u.hostname,\\n\"},{\"insert\":\" port: u.port || 80,\\n\"},{\"insert\":\" path: u.path,\\n\"},{\"insert\":\" method: cReq.method,\\n\"},{\"insert\":\" headers: cReq.headers\\n\"},{\"insert\":\" };\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" const pReq = http.request(options, pRes => {\\n\"},{\"insert\":\" cRes.writeHead(pRes.statusCode, pRes.headers);\\n\"},{\"insert\":\" pRes.pipe(cRes);\\n\"},{\"insert\":\" }).on('error', function(e) {\\n\"},{\"insert\":\" cRes.end();\\n\"},{\"insert\":\" });\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" cReq.pipe(pReq);\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"function connect(cReq, cSock) {\\n\"},{\"insert\":\" var u = url.parse('http://' + cReq.url);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" var pSock = net.connect(u.port, u.hostname, function() {\\n\"},{\"insert\":\" cSock.write('HTTP/1.1 200 Connection Established\\\\r\\\\n\\\\r\\\\n');\\n\"},{\"insert\":\" pSock.pipe(cSock);\\n\"},{\"insert\":\" }).on('error', function(e) {\\n\"},{\"insert\":\" cSock.end();\\n\"},{\"insert\":\" });\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" cSock.pipe(pSock);\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"http.createServer()\\n\"},{\"insert\":\" .on('request', request)\\n\"},{\"insert\":\" .on('connect', connect)\\n\"},{\"insert\":\" .listen(8888, '0.0.0.0');\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"需要注意的是，大部分浏览器配完隧道代理，默认只会让https走隧道代理，http如果需要走隧道代理，还需要写个Nodejs的验证\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"const options = {\\n\"},{\"insert\":\" hostname: '127.0.0.1',\\n\"},{\"insert\":\" port: 8888,\\n\"},{\"insert\":\" path: 'toutiao.com:80',\\n\"},{\"insert\":\" method: 'CONNECT'\\n\"},{\"insert\":\"};\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"const req = http.request(options);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"req.on('connect', function(res, socket) {\\n\"},{\"insert\":\" socket.write('GET / HTTP/1.1\\\\r\\\\n' +\\n\"},{\"insert\":\" 'Host: toutiao.com\\\\r\\\\n' +\\n\"},{\"insert\":\" 'Connection: Close\\\\r\\\\n' +\\n\"},{\"insert\":\" '\\\\r\\\\n');\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" socket.on('data', function(chunk) {\\n\"},{\"insert\":\" console.log(chunk.toString());\\n\"},{\"insert\":\" });\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" socket.on('end', function() {\\n\"},{\"insert\":\" console.log('socket end.');\\n\"},{\"insert\":\" });\\n\"},{\"insert\":\"});\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"req.end();\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：对于代理认识太浅，如不知道正向代理反向代理的基本原理\\n\"},{\"insert\":\"2. 3.0分：对代理的概念比较清楚，可以用Nodejs或者任意别的语言写出基本的HTTP代理的代码\\n\"},{\"insert\":\"3. 3.5分：对于HTTP普通代理和隧道代理都有不错的理解，并且最好能代码实现基本无误\\n\"},{\"insert\":\"4. 4.0分：满足以上的基础上，可以代码合二为一，并且有过实际配置经验，知道隧道代理浏览器行为，默认为了节约建立隧道的消耗只会让https走隧道代理，并知道如何让http走隧道代理\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"http普通代理：HTTP 客户端向代理发送请求报文，代理服务器需要正确地处理请求和连接（例如正确处理 Connection: keep-alive），同时向服务器发送请求，并将收到的响应转发给客户端。\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"// http 普通代理\\n\"},{\"insert\":\"const http = require('http');\\n\"},{\"insert\":\"const net = require('net');\\n\"},{\"insert\":\"const url = require('url');\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"function request(cReq, cRes) {\\n\"},{\"insert\":\" const u = url.parse(cReq.url);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" const options = {\\n\"},{\"insert\":\" hostname: u.hostname,\\n\"},{\"insert\":\" port: u.port || 80,\\n\"},{\"insert\":\" path: u.path,\\n\"},{\"insert\":\" method: cReq.method,\\n\"},{\"insert\":\" headers: cReq.headers\\n\"},{\"insert\":\" };\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" const pReq = http.request(options, pRes => {\\n\"},{\"insert\":\" cRes.writeHead(pRes.statusCode, pRes.headers);\\n\"},{\"insert\":\" pRes.pipe(cRes);\\n\"},{\"insert\":\" }).on('error', function(e) {\\n\"},{\"insert\":\" cRes.end();\\n\"},{\"insert\":\" });\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" cReq.pipe(pReq);\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"http.createServer().on('request', request).listen(8888, '0.0.0.0');\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"隧道代理：HTTP 客户端通过 CONNECT 方法请求隧道代理创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"const http = require('http');\\n\"},{\"insert\":\"const net = require('net');\\n\"},{\"insert\":\"const url = require('url');\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"function connect(cReq, cSock) {\\n\"},{\"insert\":\" const u = url.parse('http://' + cReq.url);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" const pSock = net.connect(u.port, u.hostname, function() {\\n\"},{\"insert\":\" cSock.write('HTTP/1.1 200 Connection Established\\\\r\\\\n\\\\r\\\\n');\\n\"},{\"insert\":\" pSock.pipe(cSock);\\n\"},{\"insert\":\" }).on('error', function(e) {\\n\"},{\"insert\":\" cSock.end();\\n\"},{\"insert\":\" });\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" cSock.pipe(pSock);\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"http.createServer().on('connect', connect).listen(8888, '0.0.0.0');\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"合二为一\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"const http = require('http');\\n\"},{\"insert\":\"const net = require('net');\\n\"},{\"insert\":\"const url = require('url');\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"function request(cReq, cRes) {\\n\"},{\"insert\":\" const u = url.parse(cReq.url);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" const options = {\\n\"},{\"insert\":\" hostname: u.hostname,\\n\"},{\"insert\":\" port: u.port || 80,\\n\"},{\"insert\":\" path: u.path,\\n\"},{\"insert\":\" method: cReq.method,\\n\"},{\"insert\":\" headers: cReq.headers\\n\"},{\"insert\":\" };\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" const pReq = http.request(options, pRes => {\\n\"},{\"insert\":\" cRes.writeHead(pRes.statusCode, pRes.headers);\\n\"},{\"insert\":\" pRes.pipe(cRes);\\n\"},{\"insert\":\" }).on('error', function(e) {\\n\"},{\"insert\":\" cRes.end();\\n\"},{\"insert\":\" });\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" cReq.pipe(pReq);\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"function connect(cReq, cSock) {\\n\"},{\"insert\":\" var u = url.parse('http://' + cReq.url);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" var pSock = net.connect(u.port, u.hostname, function() {\\n\"},{\"insert\":\" cSock.write('HTTP/1.1 200 Connection Established\\\\r\\\\n\\\\r\\\\n');\\n\"},{\"insert\":\" pSock.pipe(cSock);\\n\"},{\"insert\":\" }).on('error', function(e) {\\n\"},{\"insert\":\" cSock.end();\\n\"},{\"insert\":\" });\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" cSock.pipe(pSock);\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"http.createServer()\\n\"},{\"insert\":\" .on('request', request)\\n\"},{\"insert\":\" .on('connect', connect)\\n\"},{\"insert\":\" .listen(8888, '0.0.0.0');\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"需要注意的是，大部分浏览器配完隧道代理，默认只会让https走隧道代理，http如果需要走隧道代理，还需要写个Nodejs的验证\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"const options = {\\n\"},{\"insert\":\" hostname: '127.0.0.1',\\n\"},{\"insert\":\" port: 8888,\\n\"},{\"insert\":\" path: 'toutiao.com:80',\\n\"},{\"insert\":\" method: 'CONNECT'\\n\"},{\"insert\":\"};\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"const req = http.request(options);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"req.on('connect', function(res, socket) {\\n\"},{\"insert\":\" socket.write('GET / HTTP/1.1\\\\r\\\\n' +\\n\"},{\"insert\":\" 'Host: toutiao.com\\\\r\\\\n' +\\n\"},{\"insert\":\" 'Connection: Close\\\\r\\\\n' +\\n\"},{\"insert\":\" '\\\\r\\\\n');\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" socket.on('data', function(chunk) {\\n\"},{\"insert\":\" console.log(chunk.toString());\\n\"},{\"insert\":\" });\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" socket.on('end', function() {\\n\"},{\"insert\":\" console.log('socket end.');\\n\"},{\"insert\":\" });\\n\"},{\"insert\":\"});\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"req.end();\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：对于代理认识太浅，如不知道正向代理反向代理的基本原理\\n\"},{\"insert\":\"2. 3.0分：对代理的概念比较清楚，可以用Nodejs或者任意别的语言写出基本的HTTP代理的代码\\n\"},{\"insert\":\"3. 3.5分：对于HTTP普通代理和隧道代理都有不错的理解，并且最好能代码实现基本无误\\n\"},{\"insert\":\"4. 4.0分：满足以上的基础上，可以代码合二为一，并且有过实际配置经验，知道隧道代理浏览器行为，默认为了节约建立隧道的消耗只会让https走隧道代理，并知道如何让http走隧道代理\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916377636","question_title":"line-height取值的区别","i18n_question_title":"line-height取值的区别","question_skill_list":[{"name":"CSS","i18n_name":"CSS","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"*  line-height:26px;\n*  line-height:1.5;\n*  line-height:150%;\n*  line-height:1.5rem;\n### 请说出以上四种取值的区别","i18n_question_description":"*  line-height:26px;\n*  line-height:1.5;\n*  line-height:150%;\n*  line-height:1.5rem;\n### 请说出以上四种取值的区别","question_answer":"*  px/rem 单位取值\nline-height: 26px 目的就是直接定义目标元素的行高为 26px 的高度。rem同px\n*  % 百分比取值\nline-height: 150% 一般用该方式定义目标元素的行高会配合 font-size: 14px 属性使用，因为用百分比当前元素的行高为 1.5 * 14px = 21px。且如果其层叠子元素没有定义 line-height 属性，不管有没有定义 font-size 属性，其层叠子元素行高均为 21px（与自身的 font-size 没有任何关系）。\n*  倍数取值\nline-height:1.5 用该方式一般也是配合 font:14px 属性使用，但是对层叠子元素的影响效果并不同，如果层叠子元素没有定义 line-height 属性，但是定义了 font-size 属性，那这些层叠子元素的行高为继承过来的 line-height 倍数值乘以自身的 font-size 属性。\n1. 2.5分及以下：\n只能说出2个以下\n2. 3.0分：\n能说出各个取值的用法\n3. 3.5分：\n4. 4.0分：","i18n_question_answer":"*  px/rem 单位取值\nline-height: 26px 目的就是直接定义目标元素的行高为 26px 的高度。rem同px\n*  % 百分比取值\nline-height: 150% 一般用该方式定义目标元素的行高会配合 font-size: 14px 属性使用，因为用百分比当前元素的行高为 1.5 * 14px = 21px。且如果其层叠子元素没有定义 line-height 属性，不管有没有定义 font-size 属性，其层叠子元素行高均为 21px（与自身的 font-size 没有任何关系）。\n*  倍数取值\nline-height:1.5 用该方式一般也是配合 font:14px 属性使用，但是对层叠子元素的影响效果并不同，如果层叠子元素没有定义 line-height 属性，但是定义了 font-size 属性，那这些层叠子元素的行高为继承过来的 line-height 倍数值乘以自身的 font-size 属性。\n1. 2.5分及以下：\n只能说出2个以下\n2. 3.0分：\n能说出各个取值的用法\n3. 3.5分：\n4. 4.0分：","status_end_time":null,"assessment_create_time":null}],"BaseResp":{"StatusMessage":"SUCCESS","StatusCode":0,"Extra":null}},"message":"OK","special_case_code":0}
