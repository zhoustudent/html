{"code":0,"success":true,"data":{"has_more":true,"page_token":"eCtlNg8POxQ+3eBGNNc0Beob1+/9dmBRVrpYtg8JudI=","assessments_list":[{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058255971517983","question_title":"requestAnimationFrame 和 setTimeout 的区别","i18n_question_title":"requestAnimationFrame 和 setTimeout 的区别","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"requestAnimationFrame 和 setTimeout 都可以用来实现动画，它们的区别是什么","i18n_question_description":"requestAnimationFrame 和 setTimeout 都可以用来实现动画，它们的区别是什么","question_answer":"1. 执行频率不同，前者按照屏幕刷新频率执行，后者自行控制，可能有无用开销（执行频率小于刷新频率，即1帧执行多次）\n2. 前者在页面不可见时，会停止执行（省电），后者在页面不可见时仍会执行，带来不必要开销\n1. 2.5分及以下：\n2. 3.0分：提到2点及以上\n3. 3.5分：\n4. 4.0分：","i18n_question_answer":"1. 执行频率不同，前者按照屏幕刷新频率执行，后者自行控制，可能有无用开销（执行频率小于刷新频率，即1帧执行多次）\n2. 前者在页面不可见时，会停止执行（省电），后者在页面不可见时仍会执行，带来不必要开销\n1. 2.5分及以下：\n2. 3.0分：提到2点及以上\n3. 3.5分：\n4. 4.0分：","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402308471053","question_title":"如果数据库中采用64位长整型存储一个数据的id，前端通过api拿到这个id的话，会有什么问题？应该怎么解决？","i18n_question_title":"如果数据库中采用64位长整型存储一个数据的id，前端通过api拿到这个id的话，会有什么问题？应该怎么解决？","question_skill_list":[{"name":"基础","i18n_name":"基础","nick_name":null,"description":null},{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"如果数据库中采用64位长整型存储一个数据的id，前端通过api拿到这个id的话，会有什么问题？怎么解决？","i18n_question_description":"如果数据库中采用64位长整型存储一个数据的id，前端通过api拿到这个id的话，会有什么问题？怎么解决？","question_answer":"考察一下JS中整数的安全范围的概念，在头条经常会遇到长整型到前端被截断的问题，需要补一个字符串形式的id供前端使用。\n主要会涉及到JS中的最大安全整数问题\nhttps://segmentfault.com/a/1190000002608050\n3分：\n1. 能明确指出js最大安全整数问题、\n2. 能给出常见的处理安全整数的方式与手段\n3.5分：\n \n在满足3分得基础上\n3. 可以衍生提到到浮点数计算等其他问题。\n4. 能提到es6中的Integer","i18n_question_answer":"考察一下JS中整数的安全范围的概念，在头条经常会遇到长整型到前端被截断的问题，需要补一个字符串形式的id供前端使用。\n主要会涉及到JS中的最大安全整数问题\nhttps://segmentfault.com/a/1190000002608050\n3分：\n1. 能明确指出js最大安全整数问题、\n2. 能给出常见的处理安全整数的方式与手段\n3.5分：\n \n在满足3分得基础上\n3. 可以衍生提到到浮点数计算等其他问题。\n4. 能提到es6中的Integer","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402308176141","question_title":"请说明js延迟加载的方式有哪些？他们的区别是什么？","i18n_question_title":"请说明js延迟加载的方式有哪些？他们的区别是什么？","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null},{"name":"HTML","i18n_name":"HTML","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"js延迟加载的方式有哪些？他们的区别是什么","i18n_question_description":"js延迟加载的方式有哪些？他们的区别是什么","question_answer":null,"i18n_question_answer":null,"status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916492324","question_title":"渐进增强和优雅降级的区别","i18n_question_title":"渐进增强和优雅降级的区别","question_skill_list":null,"score":null,"content":null,"question_description":"什么是渐进增强和优雅降级，二者有什么区别？","i18n_question_description":"什么是渐进增强和优雅降级，二者有什么区别？","question_answer":"渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。  \n优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。\n1. 2.5分及以下：不了解或者不明白二者基本含义\n2. 3.0分：了解二者的基本概念，能说出二者主要的区别\n3. 3.5分：了解二者概念，并能举例说明那些框架采用了渐进增强，那些采用优雅降级","i18n_question_answer":"渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。  \n优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。\n1. 2.5分及以下：不了解或者不明白二者基本含义\n2. 3.0分：了解二者的基本概念，能说出二者主要的区别\n3. 3.5分：了解二者概念，并能举例说明那些框架采用了渐进增强，那些采用优雅降级","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058255971436063","question_title":"并行发送多个请求","i18n_question_title":"并行发送多个请求","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"如何并行发送多个请求，并在所有请求返回后执行后面的操作","i18n_question_description":"如何并行发送多个请求，并在所有请求返回后执行后面的操作","question_answer":"1. Promise.all(p1, p2).then()\n2. jquery/zepto defered 对象 $.when()\n3. 计数器，每个回调成功后计数器加1或减1。如果后面的操作依赖前面请求的结果，需要用数组保存每个请求的状态和返回数据 如：\n```javascript\nconst resp = [{status: 0, data: {}, index: 1}]\n```\n1. 2.5分及以下：\n2. 3.0分：答到 promise 和 自己实现\n3. 3.5分：知道 defered 及实现原理\n4. 4.0分：","i18n_question_answer":"1. Promise.all(p1, p2).then()\n2. jquery/zepto defered 对象 $.when()\n3. 计数器，每个回调成功后计数器加1或减1。如果后面的操作依赖前面请求的结果，需要用数组保存每个请求的状态和返回数据 如：\n```javascript\nconst resp = [{status: 0, data: {}, index: 1}]\n```\n1. 2.5分及以下：\n2. 3.0分：答到 promise 和 自己实现\n3. 3.5分：知道 defered 及实现原理\n4. 4.0分：","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916803620","question_title":"dns劫持","i18n_question_title":"dns劫持","question_skill_list":null,"score":null,"content":null,"question_description":"假如运营商劫持了站点部署在cdn上的静态资源的dns，可以有哪些应对措施？","i18n_question_description":"假如运营商劫持了站点部署在cdn上的静态资源的dns，可以有哪些应对措施？","question_answer":"一些地方小运营商会劫持cdn的dns，但是很少会劫持主域（如：www.toutiao.com）\n所以，可以编写一个挂在主域下的脚本，监听静态资源加载状况，如果加载失败就以主域重新加载一次；前提条件是nginx层配置了主域名指向cdn域\n\n1. 2.5分及以下：没有思路\n2. 3.0分：了解一些劫持的相关概念，给出方案\n3. 3.5分：给出方案，并给出资源重载的技术细节\n4. 4.0分：","i18n_question_answer":"一些地方小运营商会劫持cdn的dns，但是很少会劫持主域（如：www.toutiao.com）\n所以，可以编写一个挂在主域下的脚本，监听静态资源加载状况，如果加载失败就以主域重新加载一次；前提条件是nginx层配置了主域名指向cdn域\n\n1. 2.5分及以下：没有思路\n2. 3.0分：了解一些劫持的相关概念，给出方案\n3. 3.5分：给出方案，并给出资源重载的技术细节\n4. 4.0分：","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916951076","question_title":"什么是FOUC？如何避免","i18n_question_title":"什么是FOUC？如何避免","question_skill_list":[{"name":"HTML","i18n_name":"HTML","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"知道`FOUC`概念么？如何避免？","i18n_question_description":"知道`FOUC`概念么？如何避免？","question_answer":"Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。\n解决方法：把样式表放到文档的head\n1. 2.5分及以下：不了解概念\n2. 3.0分：了解概念，并给出解决方案\n3. 3.5分：给出解决方案，还能补充其他相关的页面体验优化建议\n4. 4.0分：","i18n_question_answer":"Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。\n解决方法：把样式表放到文档的head\n1. 2.5分及以下：不了解概念\n2. 3.0分：了解概念，并给出解决方案\n3. 3.5分：给出解决方案，还能补充其他相关的页面体验优化建议\n4. 4.0分：","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058255972025887","question_title":"浏览器原理","i18n_question_title":"浏览器原理","question_skill_list":[{"name":"浏览器","i18n_name":"浏览器","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"问题一：在浏览器中输入url网址，到看到网页会经历哪些阶段？\n问题二：进程和线程有什么区别？\n问题三：浏览器进程有哪些简单介绍下？","i18n_question_description":"问题一：在浏览器中输入url网址，到看到网页会经历哪些阶段？\n问题二：进程和线程有什么区别？\n问题三：浏览器进程有哪些简单介绍下？","question_answer":"问题一：\n浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，\n随后将内容通过RendererHost接口转交给Renderer进程；\n浏览器渲染流程开始：\n解析html建立dom树\n解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）\n布局render树（Layout/reflow），负责各元素尺寸、位置的计算\n绘制render树（paint），绘制页面像素信息\n浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上\n问题二：\n进程：cpu资源分配的最小单位，系统会给它分配内存\n线程：cpu调度的最小单位，线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程\n问题三：\n浏览器进程：\n主进程（Browser进程）：负责浏览器界面显示，与用户交互。如前进，后退等；负责各个页面的管理，创建和销毁其他进程；将Render进程得到的内存中的Bitmap绘制到界面上；网络资源的管理，下载等\nGPU进程：最多一个，用于3D绘制等\n第三方插件进程：每种类型的插件对应一个进程\n渲染进程（Render进程）： \n    GUI渲染线程： \n         1.负责渲染浏览器界面，解析HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。\n          2.当界面需要重绘（Repaint）或由于某种操作引发回流（reflow）时，该线程就会执行\n          3.GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。\n    JS引擎线程：\n \t\t1.也称为JS内核，负责处理JS脚本程序，运行代码。（例如V8引擎）\n         2.一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（Render 进程）中无论什么时候都只有一个JS线程在运行JS程序   \n    事件触发线程：\n    定时触发器线程：\n        1.setInterval与setTimeout所在线程\n        2.浏览器定时计数器并不是由JS引擎计数的,（因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确）\n        3.通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）    \n    异步http请求线程：\n        1.XMLHttpRequest在连接后是通过浏览器新开一个线程请求\n        2.将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JS引擎执行。\n    WebWorker线程:postMessage API，需要通过序列化对象来与线程交互特定的数据,单独开一个 Worker 线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程。只待计算出结果后，将结果通信给主线程即可  \n    （线程间关系：\n    同步任务都在JS引擎线程上执行，形成一个执行栈；异步任务会触发事件触发线程，将任务加入到任务队列中；setTimeout会触发定时触发器线程，例如等待1000ms后，将异步任务交给事件触发线程，加入到任务队列；JS引擎线程空闲（所有同步任务执行完毕），就会读取任务队列，将异步任务添加到JS引擎线程中，开始执行 ）\n  SharedWorker进程:SharedWorker 是浏览器所有页面共享的，不能采用与 Worker 同样的方式实现，因为它不隶属于某个 Render 进程，可以为多个 Render 进程共享使用.两者的区别：SharedWorker 由独立的进程管理，WebWorker 只是属于 Render 进程下的一个线程","i18n_question_answer":"问题一：\n浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，\n随后将内容通过RendererHost接口转交给Renderer进程；\n浏览器渲染流程开始：\n解析html建立dom树\n解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）\n布局render树（Layout/reflow），负责各元素尺寸、位置的计算\n绘制render树（paint），绘制页面像素信息\n浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上\n问题二：\n进程：cpu资源分配的最小单位，系统会给它分配内存\n线程：cpu调度的最小单位，线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程\n问题三：\n浏览器进程：\n主进程（Browser进程）：负责浏览器界面显示，与用户交互。如前进，后退等；负责各个页面的管理，创建和销毁其他进程；将Render进程得到的内存中的Bitmap绘制到界面上；网络资源的管理，下载等\nGPU进程：最多一个，用于3D绘制等\n第三方插件进程：每种类型的插件对应一个进程\n渲染进程（Render进程）： \n    GUI渲染线程： \n         1.负责渲染浏览器界面，解析HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。\n          2.当界面需要重绘（Repaint）或由于某种操作引发回流（reflow）时，该线程就会执行\n          3.GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。\n    JS引擎线程：\n \t\t1.也称为JS内核，负责处理JS脚本程序，运行代码。（例如V8引擎）\n         2.一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（Render 进程）中无论什么时候都只有一个JS线程在运行JS程序   \n    事件触发线程：\n    定时触发器线程：\n        1.setInterval与setTimeout所在线程\n        2.浏览器定时计数器并不是由JS引擎计数的,（因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确）\n        3.通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）    \n    异步http请求线程：\n        1.XMLHttpRequest在连接后是通过浏览器新开一个线程请求\n        2.将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JS引擎执行。\n    WebWorker线程:postMessage API，需要通过序列化对象来与线程交互特定的数据,单独开一个 Worker 线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程。只待计算出结果后，将结果通信给主线程即可  \n    （线程间关系：\n    同步任务都在JS引擎线程上执行，形成一个执行栈；异步任务会触发事件触发线程，将任务加入到任务队列中；setTimeout会触发定时触发器线程，例如等待1000ms后，将异步任务交给事件触发线程，加入到任务队列；JS引擎线程空闲（所有同步任务执行完毕），就会读取任务队列，将异步任务添加到JS引擎线程中，开始执行 ）\n  SharedWorker进程:SharedWorker 是浏览器所有页面共享的，不能采用与 Worker 同样的方式实现，因为它不隶属于某个 Render 进程，可以为多个 Render 进程共享使用.两者的区别：SharedWorker 由独立的进程管理，WebWorker 只是属于 Render 进程下的一个线程","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916000804","question_title":"js数字的语法","i18n_question_title":"js数字的语法","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"3.toString()\n3..toString()\n3...toString()","i18n_question_description":"3.toString()\n3..toString()\n3...toString()","question_answer":"答案是 error, '3', error\n在 js 中 1.1, 1., .1 都是合法的数字. 那么在解析 3.toString 的时候这个 . 到底是属于这个数字还是函数调用呢? 只能是数字, 因为3.合法\n全部答对得3分，都属于基础题","i18n_question_answer":"答案是 error, '3', error\n在 js 中 1.1, 1., .1 都是合法的数字. 那么在解析 3.toString 的时候这个 . 到底是属于这个数字还是函数调用呢? 只能是数字, 因为3.合法\n全部答对得3分，都属于基础题","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034432331592549901","question_title":"Test for three new labels","i18n_question_title":"Test for three new labels","question_skill_list":[{"name":"编码","i18n_name":"编码","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"*通过科里化实现可预测状态变更*","i18n_question_description":"*通过科里化实现可预测状态变更*","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"\\n\"},{\"insert\":\"function handleInput(event) {\\n\"},{\"insert\":\" if (event.source === 'label.type') {\\n\"},{\"insert\":\" return state.nochange();\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" return state.from(event);\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：\\n\"},{\"insert\":\"2. 3.0分：\\n\"},{\"insert\":\"3. 3.5分：\\n\"},{\"insert\":\"4. 4.0分：\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"\\n\"},{\"insert\":\"function handleInput(event) {\\n\"},{\"insert\":\" if (event.source === 'label.type') {\\n\"},{\"insert\":\" return state.nochange();\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" return state.from(event);\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：\\n\"},{\"insert\":\"2. 3.0分：\\n\"},{\"insert\":\"3. 3.5分：\\n\"},{\"insert\":\"4. 4.0分：\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null}],"BaseResp":{"StatusMessage":"SUCCESS","StatusCode":0,"Extra":null}},"message":"OK","special_case_code":0}
