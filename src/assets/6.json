{"code":0,"success":true,"data":{"has_more":true,"page_token":"OsN9TesNThAgU63HJFkPCIFeczoHotTVXBXRmdy1Wb0=","assessments_list":[{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916885540","question_title":"HTTP头中的X-Forwarded-For的意义和应用场景","i18n_question_title":"HTTP头中的X-Forwarded-For的意义和应用场景","question_skill_list":null,"score":null,"content":null,"question_description":"HTTP头中的X-Forwarded-For是用来做什么的？\n以及Remote Address、X-Real-IP的意义，哪些可以伪造，哪些不可以？\n如果需要拿用户的IP，如确认地区显示天气，应该怎么取？","i18n_question_description":"HTTP头中的X-Forwarded-For是用来做什么的？\n以及Remote Address、X-Real-IP的意义，哪些可以伪造，哪些不可以？\n如果需要拿用户的IP，如确认地区显示天气，应该怎么取？","question_answer":"X-Forwarded-For的格式：\nX-Forwarded-For: client, proxy1, proxy2\n可以看到，XFF 的内容由「英文逗号 + 空格」隔开的多个部分组成，最开始的是离服务端最远的设备 IP，然后是每一级代理设备的 IP;\nRemote Address 无法伪造，因为建立 TCP 连接需要三次握手，如果伪造了源 IP，无法建立 TCP 连接，更不会有后面的 HTTP 请求,如NodeJS可以通过以下方式获取\n```\nconst remoteAddr = req.connection.remoteAddress;\n```\nX-Real-IP 通常被 HTTP 代理用来表示与它产生 TCP 连接的设备 IP，这个设备可能是其他代理，也可能是真正的请求端\n因此，\n直接对外提供服务的 Web 应用，在进行与安全有关的操作时，只能通过 Remote Address 获取 IP，不能相信任何请求头；\n使用 Nginx 等 Web Server 进行反向代理的 Web 应用，在配置正确的前提下，要用离用户最近的可信节点追加的 IP；同时还应该禁止 Web 应用直接对外提供服务\n1. 2.5分及以下：对于这几个头的作用都不了解\n2. 3.0分：对于几个头的意义有比较清楚的了解\n3. 3.5分：对于如何取用户IP有清楚的分析，并且知道哪些可以伪造哪些不可以，对安全有一定把握","i18n_question_answer":"X-Forwarded-For的格式：\nX-Forwarded-For: client, proxy1, proxy2\n可以看到，XFF 的内容由「英文逗号 + 空格」隔开的多个部分组成，最开始的是离服务端最远的设备 IP，然后是每一级代理设备的 IP;\nRemote Address 无法伪造，因为建立 TCP 连接需要三次握手，如果伪造了源 IP，无法建立 TCP 连接，更不会有后面的 HTTP 请求,如NodeJS可以通过以下方式获取\n```\nconst remoteAddr = req.connection.remoteAddress;\n```\nX-Real-IP 通常被 HTTP 代理用来表示与它产生 TCP 连接的设备 IP，这个设备可能是其他代理，也可能是真正的请求端\n因此，\n直接对外提供服务的 Web 应用，在进行与安全有关的操作时，只能通过 Remote Address 获取 IP，不能相信任何请求头；\n使用 Nginx 等 Web Server 进行反向代理的 Web 应用，在配置正确的前提下，要用离用户最近的可信节点追加的 IP；同时还应该禁止 Web 应用直接对外提供服务\n1. 2.5分及以下：对于这几个头的作用都不了解\n2. 3.0分：对于几个头的意义有比较清楚的了解\n3. 3.5分：对于如何取用户IP有清楚的分析，并且知道哪些可以伪造哪些不可以，对安全有一定把握","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058255971468831","question_title":"何为https?https和http2有什么关系？","i18n_question_title":"何为https?https和http2有什么关系？","question_skill_list":null,"score":null,"content":null,"question_description":"简要描述HTTPS的安全机制，以及在web服务工程实践中需要注意的问题；描述http2的基本机制","i18n_question_description":"简要描述HTTPS的安全机制，以及在web服务工程实践中需要注意的问题；描述http2的基本机制","question_answer":"HTTPS是指建立在安全的传输层（通常是tls/ssl）上的HTTP协议，通过对服务器的证书的认证，解决中间人攻击等问题。\n证书(certificate)由客户端信任的的证书机构(CA)颁发，通过common name或SAN对服务进行描述；客户端通过CA的根证书对证书进行校验，并将请求域名和证书的common name/DNS域名进行验证，以检验证书的有效性。\n目前，很多web api如Notification/web rpc/Service Worker等，都要求必须使用https。\n在工程实践中，https存在以下需要注意的问题：\n  - js/css等资源必须以https形式加载，否则浏览器将拒绝执行，所以CDN必须完成对https的支持\n\t- 非https请求的图片等资源不会携带referer\n\t\n\thttp2是http协议的一个新版本，既可以明文传输也可以在https中使用。浏览器和服务器通过tls的ALPN/SNI等机制可以进行协议协商，决定使用什么协议\n1. 2.5分及以下：\n2. 3.0分：\n3. 3.5分：\n4. 4.0分：","i18n_question_answer":"HTTPS是指建立在安全的传输层（通常是tls/ssl）上的HTTP协议，通过对服务器的证书的认证，解决中间人攻击等问题。\n证书(certificate)由客户端信任的的证书机构(CA)颁发，通过common name或SAN对服务进行描述；客户端通过CA的根证书对证书进行校验，并将请求域名和证书的common name/DNS域名进行验证，以检验证书的有效性。\n目前，很多web api如Notification/web rpc/Service Worker等，都要求必须使用https。\n在工程实践中，https存在以下需要注意的问题：\n  - js/css等资源必须以https形式加载，否则浏览器将拒绝执行，所以CDN必须完成对https的支持\n\t- 非https请求的图片等资源不会携带referer\n\t\n\thttp2是http协议的一个新版本，既可以明文传输也可以在https中使用。浏览器和服务器通过tls的ALPN/SNI等机制可以进行协议协商，决定使用什么协议\n1. 2.5分及以下：\n2. 3.0分：\n3. 3.5分：\n4. 4.0分：","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916344868","question_title":"在移动高清设备上如何实现宽度为1物理像素的边线","i18n_question_title":"在移动高清设备上如何实现宽度为1物理像素的边线","question_skill_list":[{"name":"移动端","i18n_name":"移动端","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"# 在移动高清设备上如何实现宽度为1物理像素的边线","i18n_question_description":"# 在移动高清设备上如何实现宽度为1物理像素的边线","question_answer":"本题目可以采用多种解决方案：\n1. 使用width/height 按 dpr 放大，再通过 scale（1/drp) 缩小。\n2. 使用 border-image 实现，可以用真实的图片或者渐变。\n3. 使用 mediaquery，直接对 border-width 赋值 (1/dpr)px。\n回答任意解法正确即可。如能说出每种解法的优劣，可酌情加分。","i18n_question_answer":"本题目可以采用多种解决方案：\n1. 使用width/height 按 dpr 放大，再通过 scale（1/drp) 缩小。\n2. 使用 border-image 实现，可以用真实的图片或者渐变。\n3. 使用 mediaquery，直接对 border-width 赋值 (1/dpr)px。\n回答任意解法正确即可。如能说出每种解法的优劣，可酌情加分。","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445585932387876","question_title":"实现千位分隔符","i18n_question_title":"实现千位分隔符","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null},{"name":"基础算法","i18n_name":"基础算法","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"给一个数字，比如：1234567.90，转化成：1,234,567.90","i18n_question_description":"给一个数字，比如：1234567.90，转化成：1,234,567.90","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"js\\n\"},{\"insert\":\"function commafy(num) {\\n\"},{\"insert\":\" return num && num\\n\"},{\"insert\":\" .toString()\\n\"},{\"insert\":\" .replace(/^\\\\d+/, (m) => m.replace(/(?=(?!^)(\\\\d{3})+$)/g, ','));\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"console.log(commafy(1234567.90)); //1,234,567.90\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：没有思路，写不出来\\n\"},{\"insert\":\"2. 3.0分：正确给出一种解法\\n\"},{\"insert\":\"3. 3.5分：给出至少一种解法，考虑到小数及边界检查等，并能提出其他思路\\n\"},{\"insert\":\"4. 4.0分：\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"js\\n\"},{\"insert\":\"function commafy(num) {\\n\"},{\"insert\":\" return num && num\\n\"},{\"insert\":\" .toString()\\n\"},{\"insert\":\" .replace(/^\\\\d+/, (m) => m.replace(/(?=(?!^)(\\\\d{3})+$)/g, ','));\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"console.log(commafy(1234567.90)); //1,234,567.90\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：没有思路，写不出来\\n\"},{\"insert\":\"2. 3.0分：正确给出一种解法\\n\"},{\"insert\":\"3. 3.5分：给出至少一种解法，考虑到小数及边界检查等，并能提出其他思路\\n\"},{\"insert\":\"4. 4.0分：\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445596262614558","question_title":"用数组的reduce方法实现map方法","i18n_question_title":"用数组的reduce方法实现map方法","question_skill_list":[{"name":"语言基础","i18n_name":"语言基础","nick_name":null,"description":null},{"name":"编码","i18n_name":"编码","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"用数组的reduce方法实现map方法","i18n_question_description":"用数组的reduce方法实现map方法","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"\\n\"},{\"insert\":\"// 代码实现\\n\"},{\"insert\":\"Array.prototype.map2 = function(f) {\\n\"},{\"insert\":\" return this.reduce(function(result, x, index, arr) {\\n\"},{\"insert\":\" result.push(f(x, index));\\n\"},{\"insert\":\" return result;\\n\"},{\"insert\":\" }, []);\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"// 测试代码\\n\"},{\"insert\":\"var res = [1, 3, 5, 7].map2(function(item, idx){\\n\"},{\"insert\":\" return item * 2;\\n\"},{\"insert\":\"});\\n\"},{\"insert\":\"console.log(res);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：对map和reduce的基本用法不了解\\n\"},{\"insert\":\"2. 3.0分：理解map和reduce的基础用法，并且可以通过reduce实现map\\n\"},{\"insert\":\"3. 3.5分：对map和reduce深入理解，明白map是reduce的一种特例,并且知道transduce\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"\\n\"},{\"insert\":\"// 代码实现\\n\"},{\"insert\":\"Array.prototype.map2 = function(f) {\\n\"},{\"insert\":\" return this.reduce(function(result, x, index, arr) {\\n\"},{\"insert\":\" result.push(f(x, index));\\n\"},{\"insert\":\" return result;\\n\"},{\"insert\":\" }, []);\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"// 测试代码\\n\"},{\"insert\":\"var res = [1, 3, 5, 7].map2(function(item, idx){\\n\"},{\"insert\":\" return item * 2;\\n\"},{\"insert\":\"});\\n\"},{\"insert\":\"console.log(res);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：对map和reduce的基本用法不了解\\n\"},{\"insert\":\"2. 3.0分：理解map和reduce的基础用法，并且可以通过reduce实现map\\n\"},{\"insert\":\"3. 3.5分：对map和reduce深入理解，明白map是reduce的一种特例,并且知道transduce\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495755137517831","question_title":"进行CSRF漏洞扫描的原理和防御方式是什么？","i18n_question_title":"进行CSRF漏洞扫描的原理和防御方式是什么？","question_skill_list":[{"name":"web安全","i18n_name":"web安全","nick_name":null,"description":null},{"name":"漏洞原理","i18n_name":"漏洞原理","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"如题","i18n_question_description":"如题","question_answer":"CSRF 就是在用户不知情的情况下，发出了请求，让用户做了不该做的操作。\n举个例子，比如你的一个网站中有个 img 标签，src 指向的是微博关注某人的接口，\n那么当用户访问你的网站时，就会在微博上关注那个人，而且这个操作用户是不知情的。\n因为 img src 发出的跨域请求，也是会携带 cookie 的，所以如果用户在微博登录过，\n那么就会带有微博的登录授权。同理，如果是其他操作，可能也存在这种漏洞，比较危险的情况就是付款。\n一般会采用 CSRF token 的方式防御，就是关键请求得要换取一个一次有效的 token 才有权限。\n1. 2.5分及以下：完全没有概念，不清楚这个安全问题；\n2. 3.0分：能够简单介绍出问题；\n3. 3.5分：能够介绍出防御方案；\n4. 4.0分：结合实践介绍出更多，或者更多其他细节等；","i18n_question_answer":"CSRF 就是在用户不知情的情况下，发出了请求，让用户做了不该做的操作。\n举个例子，比如你的一个网站中有个 img 标签，src 指向的是微博关注某人的接口，\n那么当用户访问你的网站时，就会在微博上关注那个人，而且这个操作用户是不知情的。\n因为 img src 发出的跨域请求，也是会携带 cookie 的，所以如果用户在微博登录过，\n那么就会带有微博的登录授权。同理，如果是其他操作，可能也存在这种漏洞，比较危险的情况就是付款。\n一般会采用 CSRF token 的方式防御，就是关键请求得要换取一个一次有效的 token 才有权限。\n1. 2.5分及以下：完全没有概念，不清楚这个安全问题；\n2. 3.0分：能够简单介绍出问题；\n3. 3.5分：能够介绍出防御方案；\n4. 4.0分：结合实践介绍出更多，或者更多其他细节等；","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239915722276","question_title":"聊聊你对现代前端技术是怎么认识的？","i18n_question_title":"聊聊你对现代前端技术是怎么认识的？","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":null,"i18n_question_description":null,"question_answer":"1. 组件化，数据驱动，函数式，可测试；\n2. 前端安全，\n3. mvc，mvp，mvvm，flux等架构模式；\n4. es6/7；\n5. 自动化构建；\n6. 性能优化，监控数据采集；\n8. 跨栈开发（node，hybrid，elestron, RN，同构等）；\n9. 预编译（babel,typescript）\n10. webgl、webvr\n11. asm\n12. pwa\n能说明前端的主流技术领域、覆盖面和趋势，前端工程师在当前扮演着什么样的角色，得3分；有自己独到的见解，对新技术保持持续关注并有深入研究，得3.5分","i18n_question_answer":"1. 组件化，数据驱动，函数式，可测试；\n2. 前端安全，\n3. mvc，mvp，mvvm，flux等架构模式；\n4. es6/7；\n5. 自动化构建；\n6. 性能优化，监控数据采集；\n8. 跨栈开发（node，hybrid，elestron, RN，同构等）；\n9. 预编译（babel,typescript）\n10. webgl、webvr\n11. asm\n12. pwa\n能说明前端的主流技术领域、覆盖面和趋势，前端工程师在当前扮演着什么样的角色，得3分；有自己独到的见解，对新技术保持持续关注并有深入研究，得3.5分","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239904597511","question_title":"ES6的Proxy和Reflect有何用","i18n_question_title":"ES6的Proxy和Reflect有何用","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"1.  proxy和reflect的作用是什么\n1.  和es5中的definePropery相比有何优势\n1.  也可以结合vue的数据双向绑定原理考察下","i18n_question_description":"1.  proxy和reflect的作用是什么\n1.  和es5中的definePropery相比有何优势\n1.  也可以结合vue的数据双向绑定原理考察下","question_answer":"proxy是es6的新特性，简单来讲，即是对目标对象的属性读取、设置，亦或函数调用等操作进行拦截（处理），\n与ES5 setter/getter访问器的区别是，在proxy中，proxy.age=1,只会执行 set的方法，而不是像ES5中的setter，会先执行set，后执行get。\n且proxy中的set必须有返回值，ES5的setter不用，这也正是因为在他之后还会执行getter,所以不需要。\nReflect与ES5的Object有点类似，包含了对象语言内部的方法，Reflect也有13种方法，与proxy中的方法一一对应。\nProxy相当于去修改设置对象的属性行为，而Reflect则是获取对象的这些行为。\n1、对proxy和relect的概念理解\n2、结合自己使用情况看看是否用做深入实践\n3、definePropery的掌握情况","i18n_question_answer":"proxy是es6的新特性，简单来讲，即是对目标对象的属性读取、设置，亦或函数调用等操作进行拦截（处理），\n与ES5 setter/getter访问器的区别是，在proxy中，proxy.age=1,只会执行 set的方法，而不是像ES5中的setter，会先执行set，后执行get。\n且proxy中的set必须有返回值，ES5的setter不用，这也正是因为在他之后还会执行getter,所以不需要。\nReflect与ES5的Object有点类似，包含了对象语言内部的方法，Reflect也有13种方法，与proxy中的方法一一对应。\nProxy相当于去修改设置对象的属性行为，而Reflect则是获取对象的这些行为。\n1、对proxy和relect的概念理解\n2、结合自己使用情况看看是否用做深入实践\n3、definePropery的掌握情况","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402307291405","question_title":"请列举说明几个在web中实现长连接的技术方案或手段","i18n_question_title":"请列举说明几个在web中实现长连接的技术方案或手段","question_skill_list":[{"name":"性能优化","i18n_name":"性能优化","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"本地主要考察候选人对长连接技术的概念理解和区分，如果能回答答出大致的名词可以继续追问一些具体的激技术实现细节和存在的优缺点等等。","i18n_question_description":"本地主要考察候选人对长连接技术的概念理解和区分，如果能回答答出大致的名词可以继续追问一些具体的激技术实现细节和存在的优缺点等等。","question_answer":"* Long Polling\n* Server-Sent Events\n* Websockets\n* Comet\n1. 2.5分及以下：不知道长连接的基本概念和使用场景\n2. 3.0分：能说出Long Polling，SSE，Websockets，webrtc等基本概念\n3. 3.5分：能具体说清楚每个方案的大致实现特点和适用场景\n4. 4.0分：有一定的实操经验，对各个方案的都有深入理解并且能详实地画出示意图或者解释清楚各个方案存在的优缺点","i18n_question_answer":"* Long Polling\n* Server-Sent Events\n* Websockets\n* Comet\n1. 2.5分及以下：不知道长连接的基本概念和使用场景\n2. 3.0分：能说出Long Polling，SSE，Websockets，webrtc等基本概念\n3. 3.5分：能具体说清楚每个方案的大致实现特点和适用场景\n4. 4.0分：有一定的实操经验，对各个方案的都有深入理解并且能详实地画出示意图或者解释清楚各个方案存在的优缺点","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402307946765","question_title":"请用数组的reduce方法实现map方法","i18n_question_title":"请用数组的reduce方法实现map方法","question_skill_list":[{"name":"语言基础","i18n_name":"语言基础","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"用数组的reduce方法实现map方法","i18n_question_description":"用数组的reduce方法实现map方法","question_answer":null,"i18n_question_answer":null,"status_end_time":null,"assessment_create_time":null}],"BaseResp":{"StatusMessage":"SUCCESS","StatusCode":0,"Extra":null}},"message":"OK","special_case_code":0}
