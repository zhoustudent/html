{"code":0,"success":true,"data":{"has_more":true,"page_token":"q5cekSTDE0QIYPUQIPXyJQ73A+HHPwmZN6LuAY0KQSY=","assessments_list":[{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058255971599903","question_title":"promise运行过程解答","i18n_question_title":"promise运行过程解答","question_skill_list":null,"score":null,"content":null,"question_description":"如下代码的运行结果是什么？\n```javascript\n process.nextTick(() => {console.log('nextTick')})\nPromise.resolve().then(()=> {console.log('promise1');}).then(()=> {\n  console.log('promise2');\n});\nsetImmediate(() => {console.log('setImmediate')})\nconsole.log('end') \n```","i18n_question_description":"如下代码的运行结果是什么？\n```javascript\n process.nextTick(() => {console.log('nextTick')})\nPromise.resolve().then(()=> {console.log('promise1');}).then(()=> {\n  console.log('promise2');\n});\nsetImmediate(() => {console.log('setImmediate')})\nconsole.log('end') \n```","question_answer":"1. end -> nextTick -> promise1 -> promise2-> setImmediate\n1. process.nextTick 和 promise.then 都属于 microtask，而 setImmediate 属于 macrotask，在事件循环的 check 阶段执行。\n1. 事件循环的每个阶段（macrotask）之间都会执行 microtask，事件循环的开始会先执行一次 microtask。\n1. 2.5分及以下：完全没有头绪，不知道promise的用法\n2. 3.0分：能说对到end -> nextTick，知道基本异步使用的概念\n3. 3.5分：能说对end -> nextTick -> promise1 -> promise2 -> setImmediate，知道promise中的resolve的执行时机\n4. 4.0分：能很清晰地说清楚promise优化异步的操作思路，能回答清楚setTimeout/setImmediate/process.nextTick的区别。\n5. 能提到macrotasks和microtasks有加分","i18n_question_answer":"1. end -> nextTick -> promise1 -> promise2-> setImmediate\n1. process.nextTick 和 promise.then 都属于 microtask，而 setImmediate 属于 macrotask，在事件循环的 check 阶段执行。\n1. 事件循环的每个阶段（macrotask）之间都会执行 microtask，事件循环的开始会先执行一次 microtask。\n1. 2.5分及以下：完全没有头绪，不知道promise的用法\n2. 3.0分：能说对到end -> nextTick，知道基本异步使用的概念\n3. 3.5分：能说对end -> nextTick -> promise1 -> promise2 -> setImmediate，知道promise中的resolve的执行时机\n4. 4.0分：能很清晰地说清楚promise优化异步的操作思路，能回答清楚setTimeout/setImmediate/process.nextTick的区别。\n5. 能提到macrotasks和microtasks有加分","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034432331592484365","question_title":"实现一个简单的Event类（观察者模式）","i18n_question_title":"实现一个简单的Event类（观察者模式）","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null},{"name":"编码","i18n_name":"编码","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"请实现一个观察者模式，拥有四个方法on,off,once和trigger\nconst Event = {\n    on() {}   // 绑定\n    off() {}  // 解绑\n    once() {}   // 绑定一次\n    trigger() {}  // 触发事件\n};","i18n_question_description":"请实现一个观察者模式，拥有四个方法on,off,once和trigger\nconst Event = {\n    on() {}   // 绑定\n    off() {}  // 解绑\n    once() {}   // 绑定一次\n    trigger() {}  // 触发事件\n};","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"```javascript function Event() { if (!(this instanceof Event)) { return new Event(); } this._callbacks = {}; } Event.prototype.on = function (type, handler) { this_callbacks = this._callbacks || {}; this._callbacks[type] = this.callbacks[type] || []; this._callbacks[type].push(handler); return this; }; Event.prototype.off = function (type, handler) { var list = this._callbacks[type]; if (list) { for (var i = list.length; i >= 0; --i) { if (list[i] === handler) { list.splice(i, 1); } } } return this; }; Event.prototype.trigger = function (type, data) { var list = this._callbacks[type]; if (list) { for (var i = 0, len = list.length; i < len; ++i) { list[i].call(this, data); } } }; Event.prototype.once = function (type, handler) { var self = this; function wrapper() { handler.apply(self, arguments); self.off(type, wrapper); } this.on(type, wrapper); return this; }; ```\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"能基本实现，有一些问题 给3分 能给出实现，边界处理没有问题，给 3.5 分\\n\"},{\"insert\":\"\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"```javascript function Event() { if (!(this instanceof Event)) { return new Event(); } this._callbacks = {}; } Event.prototype.on = function (type, handler) { this_callbacks = this._callbacks || {}; this._callbacks[type] = this.callbacks[type] || []; this._callbacks[type].push(handler); return this; }; Event.prototype.off = function (type, handler) { var list = this._callbacks[type]; if (list) { for (var i = list.length; i >= 0; --i) { if (list[i] === handler) { list.splice(i, 1); } } } return this; }; Event.prototype.trigger = function (type, data) { var list = this._callbacks[type]; if (list) { for (var i = 0, len = list.length; i < len; ++i) { list[i].call(this, data); } } }; Event.prototype.once = function (type, handler) { var self = this; function wrapper() { handler.apply(self, arguments); self.off(type, wrapper); } this.on(type, wrapper); return this; }; ```\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"能基本实现，有一些问题 给3分 能给出实现，边界处理没有问题，给 3.5 分\\n\"},{\"insert\":\"\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916115492","question_title":"CSS 属性 position 有 5个值，请写出你常用的三个","i18n_question_title":"CSS 属性 position 有 5个值，请写出你常用的三个","question_skill_list":[{"name":"CSS","i18n_name":"CSS","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"CSS 属性 position 有 5个值，请写出你常用的三个","i18n_question_description":"CSS 属性 position 有 5个值，请写出你常用的三个","question_answer":"relative、absolute、fixed、static、inherit、initial\n本题答对三个得3分。不能得更高分数","i18n_question_answer":"relative、absolute、fixed、static、inherit、initial\n本题答对三个得3分。不能得更高分数","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402307782925","question_title":"请简述display: none;与visibility: hidden;的区别","i18n_question_title":"请简述display: none;与visibility: hidden;的区别","question_skill_list":[{"name":"CSS","i18n_name":"CSS","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"这两个元素都能设置元素不可见，考察两者的区别","i18n_question_description":"这两个元素都能设置元素不可见，考察两者的区别","question_answer":"1. display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见\n2. display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式\n3. 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘\n4. 读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容\n1. 2.5分及以下：不了解相关概念\n2. 3.0分：了解相关概念，并答出3~4点\n3. 3.5分：\n4. 4.0分：","i18n_question_answer":"1. display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见\n2. display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式\n3. 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘\n4. 读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容\n1. 2.5分及以下：不了解相关概念\n2. 3.0分：了解相关概念，并答出3~4点\n3. 3.5分：\n4. 4.0分：","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402307750157","question_title":"请编写JAVAscript深度克隆函数deepClone","i18n_question_title":"请编写JAVAscript深度克隆函数deepClone","question_skill_list":[{"name":"js","i18n_name":"js","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"编写JAVAscript深度克隆函数deepClone","i18n_question_description":"编写JAVAscript深度克隆函数deepClone","question_answer":null,"i18n_question_answer":null,"status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402308077837","question_title":"请谈一谈如何抓取豆瓣电影的数据","i18n_question_title":"请谈一谈如何抓取豆瓣电影的数据","question_skill_list":[{"name":"工程设计","i18n_name":"工程设计","nick_name":null,"description":null},{"name":"工程构建","i18n_name":"工程构建","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"如题，如果对方确实是前端，那可以说下，最好使用前端的方式，比如只在浏览器中的方式。","i18n_question_description":"如题，如果对方确实是前端，那可以说下，最好使用前端的方式，比如只在浏览器中的方式。","question_answer":"这道题主要是考察面试者对于前端技术的灵活运用，这道题的答案是多种的，可以在 Nodejs 中跑一个模拟浏览器环境去抓取，也可以是用真正的 Python 爬虫去爬。\n但是这里推荐的一个方式是，通过浏览器的控制台，直接去爬取，核心原理就是每次做 dom 的分析，\n然后 http 请求下一个数据页面，并且将页面替换，再不断进行下去。\n其实这道题最好是一道上机题目，直接让面试者搞定。\n另外，碰巧我之前做过这个事情，\n\n1. 2.5分及以下：面试者无法回答，也没有什么思路；\n2. 3.0分：介绍了思路，听起来是可行的；\n3. 3.5分：能够比较详细的说明实现方式，甚至实现过程中可能遇到的问题；\n4. 4.0分：直接可以在电脑上搞定的；","i18n_question_answer":"这道题主要是考察面试者对于前端技术的灵活运用，这道题的答案是多种的，可以在 Nodejs 中跑一个模拟浏览器环境去抓取，也可以是用真正的 Python 爬虫去爬。\n但是这里推荐的一个方式是，通过浏览器的控制台，直接去爬取，核心原理就是每次做 dom 的分析，\n然后 http 请求下一个数据页面，并且将页面替换，再不断进行下去。\n其实这道题最好是一道上机题目，直接让面试者搞定。\n另外，碰巧我之前做过这个事情，\n\n1. 2.5分及以下：面试者无法回答，也没有什么思路；\n2. 3.0分：介绍了思路，听起来是可行的；\n3. 3.5分：能够比较详细的说明实现方式，甚至实现过程中可能遇到的问题；\n4. 4.0分：直接可以在电脑上搞定的；","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916279332","question_title":"获取元素左上角的坐标","i18n_question_title":"获取元素左上角的坐标","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"如何获取一个元素距离浏览器窗口左上角的坐标\n考察对dom api的掌握和对offsetTop和offsetLeft理解","i18n_question_description":"如何获取一个元素距离浏览器窗口左上角的坐标\n考察对dom api的掌握和对offsetTop和offsetLeft理解","question_answer":"1. 使用getBoundingClientRect\n2. 遍历offsetParent的offsetTop和offsetLeft 在减去scrollY\n1. 2.5分及以下：\n回答出不来\n2. 3.0分：\n可以使用其中一种回答出来 使用第二种需要知道offsetTop和offsetLeft是相对哪个元素\n3. 3.5分：\n可以使用两种方法实现","i18n_question_answer":"1. 使用getBoundingClientRect\n2. 遍历offsetParent的offsetTop和offsetLeft 在减去scrollY\n1. 2.5分及以下：\n回答出不来\n2. 3.0分：\n可以使用其中一种回答出来 使用第二种需要知道offsetTop和offsetLeft是相对哪个元素\n3. 3.5分：\n可以使用两种方法实现","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239904630279","question_title":"如何理解虚拟DOM?","i18n_question_title":"如何理解虚拟DOM?","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"如何理解虚拟DOM?","i18n_question_description":"如何理解虚拟DOM?","question_answer":"对虚拟dom和diff算法中的一些细节理解与考察\n能说出虚拟dom diff算法的大致原理和渲染流程，得 3 分；\n能写出 diff 算法的核心部分，得 3.5 分以上","i18n_question_answer":"对虚拟dom和diff算法中的一些细节理解与考察\n能说出虚拟dom diff算法的大致原理和渲染流程，得 3 分；\n能写出 diff 算法的核心部分，得 3.5 分以上","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916590628","question_title":"考察作用域和立即执行函数","i18n_question_title":"考察作用域和立即执行函数","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"如下代码会输出的全部是5，为什么？\n```javascript\nfor(var i = 0; i < 5; i++) {\n    setTimeout(function() {\n        console.log(i);  \n    }, 1000);\n}\n```\n如果想让输出0、1、2、3、4该怎么做？","i18n_question_description":"如下代码会输出的全部是5，为什么？\n```javascript\nfor(var i = 0; i < 5; i++) {\n    setTimeout(function() {\n        console.log(i);  \n    }, 1000);\n}\n```\n如果想让输出0、1、2、3、4该怎么做？","question_answer":"1.  ### 使用let\n```javascript\nfor(let i = 0; i < 5; i++) {\n    setTimeout(function() {\n        console.log(i);  \n    }, 1000);\n}\n```\n2.  ### 使用立即执行函数\n```javascript\nfor(var i = 0; i < 5; i++) {\n    (function(i) {\n      setTimeout(function() {\n        console.log(i);  \n      }, 1000);\n    })(i)\n}\n```\n1. 2.5分及以下：\n不能说出为什么全部输出5，也不能给出对应的办法\n2. 3.0分：\n能说出原因（任务队列），也能给出一种解决方法\n3. 3.5分：\n能给出let和立即执行函数，也能说出区别\n4. 4.0分：","i18n_question_answer":"1.  ### 使用let\n```javascript\nfor(let i = 0; i < 5; i++) {\n    setTimeout(function() {\n        console.log(i);  \n    }, 1000);\n}\n```\n2.  ### 使用立即执行函数\n```javascript\nfor(var i = 0; i < 5; i++) {\n    (function(i) {\n      setTimeout(function() {\n        console.log(i);  \n      }, 1000);\n    })(i)\n}\n```\n1. 2.5分及以下：\n不能说出为什么全部输出5，也不能给出对应的办法\n2. 3.0分：\n能说出原因（任务队列），也能给出一种解决方法\n3. 3.5分：\n能给出let和立即执行函数，也能说出区别\n4. 4.0分：","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916099108","question_title":"HTTPS是如何保证连接安全的？","i18n_question_title":"HTTPS是如何保证连接安全的？","question_skill_list":null,"score":null,"content":null,"question_description":"https通过那些机制来时实现安全通道的创建和、数据的安全传输的","i18n_question_description":"https通过那些机制来时实现安全通道的创建和、数据的安全传输的","question_answer":"1、传输层安全协议（TLS）\n2、公钥加密机制\n3、Diffie-Hellman\n    这种密钥交换最常使用是Diffie-Hellman的密钥交换法。这项过程允许服务器和客户端双方商定共同的保密信息，而不需要在传输过程中交换这个信息。这样一来，即使嗅探者查看每个数据包，也不能确定连接上传输的共享密码是什么。\n4、对称式加密机制\n    每次会话中只需要产生一次公钥交换的过程。在接受了同一个共享保密信息以后，服务器和客户端之间会使用更为高效的对称式加密机制进行通信，省去了来回交换的额外花销。\n在接受了之前的共享保密信息之后，还会使用一套密码机制（一般是一组加密算法），使用共享的密码安全地通信，加密解密各自的信息。而窃听者只会看到一堆乱码在传来传去。\n5、身份认证\n    DH式密钥交换允许双方创建私有的，共有的密码，但通信双方怎么确保是真正想要对话的人呢？这里就涉及到了身份认证的问题。\n考察对https的安全机制的了解","i18n_question_answer":"1、传输层安全协议（TLS）\n2、公钥加密机制\n3、Diffie-Hellman\n    这种密钥交换最常使用是Diffie-Hellman的密钥交换法。这项过程允许服务器和客户端双方商定共同的保密信息，而不需要在传输过程中交换这个信息。这样一来，即使嗅探者查看每个数据包，也不能确定连接上传输的共享密码是什么。\n4、对称式加密机制\n    每次会话中只需要产生一次公钥交换的过程。在接受了同一个共享保密信息以后，服务器和客户端之间会使用更为高效的对称式加密机制进行通信，省去了来回交换的额外花销。\n在接受了之前的共享保密信息之后，还会使用一套密码机制（一般是一组加密算法），使用共享的密码安全地通信，加密解密各自的信息。而窃听者只会看到一堆乱码在传来传去。\n5、身份认证\n    DH式密钥交换允许双方创建私有的，共有的密码，但通信双方怎么确保是真正想要对话的人呢？这里就涉及到了身份认证的问题。\n考察对https的安全机制的了解","status_end_time":null,"assessment_create_time":null}],"BaseResp":{"StatusMessage":"SUCCESS","StatusCode":0,"Extra":null}},"message":"OK","special_case_code":0}
