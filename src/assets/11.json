{"code":0,"success":true,"data":{"has_more":true,"page_token":"qNqlRl73G6uLtIwAXD0Nesu+O1IcH8MmepTISweM3KU=","assessments_list":[{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445591128049165","question_title":"用能力有限的服务器端 API 的 JS SDK 实现本地需求","i18n_question_title":"用能力有限的服务器端 API 的 JS SDK 实现本地需求","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null},{"name":"基础算法","i18n_name":"基础算法","nick_name":null,"description":null},{"name":"前端基础","i18n_name":"前端基础","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"排版更好的版本：https://bytedance.feishu.cn/space/doc/doccndsPjt0k6zykA3ZFEkYBOtf\n## 第一阶段问题：\n假设有一台本地机器，无法做加法运算，因此无法执行 `a + b`、`a+ = 1` 这样的 JS 代码，然后我们提供一个服务器端的 API，可以传两个数字类型的参数，响应结果是这两个参数的和，这个 API 的 JS SDK 的使用方法如下：\nasyncAdd(3, 5, (err, result) => {\nconsole.log(result) // 8\n})\n现在要求实现一个 sum 函数，支持以下用法：\n(async () => {\nconst result1 = await sum(1, 4, 6, 9, 10, 14)\nconst result2 = await sum(3, 4, 9, 20, 22, 30, 32, 100, 200)\nconst result3 = await sum(1, 6, 10, 15)\nconsole.log([result1, result2, result3]) // [44, 402, 32]\n})()\n要求 sum 能在最短的时间里返回以上结果\n--------------------对候选人隐藏的分割线-----------------------\n候选人完成第一阶段的实现和优化后，再给出以下阶段的问题，避免一开始就提到『限流』，提示候选人利用并发\n--------------------对候选人隐藏的分割线-----------------------\n## 第二阶段问题\n用法改成这样：\n(async () => {\nawait setRateLimiterMode({ mode: 1, max: 3 })\nconst result1 = await sum(1, 4, 6, 9, 10, 14)\nawait setRateLimiterMode({ mode: 2, max: 2, duration: 1000 })\nconst result2 = await sum(3, 4, 9, 20, 22, 30, 32, 100, 200)\nawait setRateLimiterMode({ mode: 3 })\nconst result3 = await sum(1, 6, 10, 15)\nconsole.log([result1, result2, result3]) // [44, 402, 32]\n})()\nSDK 提供了一个新方法 setRateLimiterMode，可以设置服务器端 API 的限流模式，三次调用的配置参数对应的模式分别是：\n最多同时处理 3 个请求\n在 1 秒内最多处理 2 个请求\nAPI 提供三个节点，每个节点有独立的限流（方式 1 或方式 2）\n一旦超出限流，服务器端 API 就返回错误响应（asyncAdd 的 callback 参数里的 err）\n针对模式 3，asyncAdd 增加了一个可选的 options 参数，能指定请求哪个节点、用什么限流模式：\nasyncAdd(3, 5, (err, result) => {\nconsole.log(result) // 8\n}, { endpoint: 1, rateLimitMode: 2 })\n要求修改 sum 的实现，稳定得到以上用法的结果，并保持性能最优","i18n_question_description":"排版更好的版本：https://bytedance.feishu.cn/space/doc/doccndsPjt0k6zykA3ZFEkYBOtf\n## 第一阶段问题：\n假设有一台本地机器，无法做加法运算，因此无法执行 `a + b`、`a+ = 1` 这样的 JS 代码，然后我们提供一个服务器端的 API，可以传两个数字类型的参数，响应结果是这两个参数的和，这个 API 的 JS SDK 的使用方法如下：\nasyncAdd(3, 5, (err, result) => {\nconsole.log(result) // 8\n})\n现在要求实现一个 sum 函数，支持以下用法：\n(async () => {\nconst result1 = await sum(1, 4, 6, 9, 10, 14)\nconst result2 = await sum(3, 4, 9, 20, 22, 30, 32, 100, 200)\nconst result3 = await sum(1, 6, 10, 15)\nconsole.log([result1, result2, result3]) // [44, 402, 32]\n})()\n要求 sum 能在最短的时间里返回以上结果\n--------------------对候选人隐藏的分割线-----------------------\n候选人完成第一阶段的实现和优化后，再给出以下阶段的问题，避免一开始就提到『限流』，提示候选人利用并发\n--------------------对候选人隐藏的分割线-----------------------\n## 第二阶段问题\n用法改成这样：\n(async () => {\nawait setRateLimiterMode({ mode: 1, max: 3 })\nconst result1 = await sum(1, 4, 6, 9, 10, 14)\nawait setRateLimiterMode({ mode: 2, max: 2, duration: 1000 })\nconst result2 = await sum(3, 4, 9, 20, 22, 30, 32, 100, 200)\nawait setRateLimiterMode({ mode: 3 })\nconst result3 = await sum(1, 6, 10, 15)\nconsole.log([result1, result2, result3]) // [44, 402, 32]\n})()\nSDK 提供了一个新方法 setRateLimiterMode，可以设置服务器端 API 的限流模式，三次调用的配置参数对应的模式分别是：\n最多同时处理 3 个请求\n在 1 秒内最多处理 2 个请求\nAPI 提供三个节点，每个节点有独立的限流（方式 1 或方式 2）\n一旦超出限流，服务器端 API 就返回错误响应（asyncAdd 的 callback 参数里的 err）\n针对模式 3，asyncAdd 增加了一个可选的 options 参数，能指定请求哪个节点、用什么限流模式：\nasyncAdd(3, 5, (err, result) => {\nconsole.log(result) // 8\n}, { endpoint: 1, rateLimitMode: 2 })\n要求修改 sum 的实现，稳定得到以上用法的结果，并保持性能最优","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"\\n\"},{\"insert\":\"2 分：能不使用任何 JS 加法运算，用 callback 风格的 JS SDK，实现 async/await 风格的 API，得到期望中的结果。\\n\"},{\"insert\":\"3 分：对于第一阶段，能实现性能最优，最大化并发的调用 SDK。最基本的优化是把参数两两配对，并发的获得结果，然后再次配对，进一步的优化是充分利用异步请求响应的时间差，把每次获得的响应结果放到一个栈或池里，只要凑齐了一个配对，就拿出来求和，动态的确保最大化并发。还有一个优化点是在客户端缓存加法结果。对于第二阶段，能正确修改实现。\\n\"},{\"insert\":\"3.5 分：能用递归的方式简化实现。在第二阶段能把不同限流方式的规则和处理从实现中抽象出来，支持尽可能灵活的配置\\n\"},{\"insert\":\"\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"\\n\"},{\"insert\":\"2 分：能不使用任何 JS 加法运算，用 callback 风格的 JS SDK，实现 async/await 风格的 API，得到期望中的结果。\\n\"},{\"insert\":\"3 分：对于第一阶段，能实现性能最优，最大化并发的调用 SDK。最基本的优化是把参数两两配对，并发的获得结果，然后再次配对，进一步的优化是充分利用异步请求响应的时间差，把每次获得的响应结果放到一个栈或池里，只要凑齐了一个配对，就拿出来求和，动态的确保最大化并发。还有一个优化点是在客户端缓存加法结果。对于第二阶段，能正确修改实现。\\n\"},{\"insert\":\"3.5 分：能用递归的方式简化实现。在第二阶段能把不同限流方式的规则和处理从实现中抽象出来，支持尽可能灵活的配置\\n\"},{\"insert\":\"\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402307766541","question_title":"请简述transform原理","i18n_question_title":"请简述transform原理","question_skill_list":[{"name":"CSS3","i18n_name":"CSS3","nick_name":null,"description":null},{"name":"CSS","i18n_name":"CSS","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"transform同时设置多个值，比如translate(30px,0px) rotate(45deg)和rotate(45deg) translate(30px,0px)效果是否相同，为什么？","i18n_question_description":"transform同时设置多个值，比如translate(30px,0px) rotate(45deg)和rotate(45deg) translate(30px,0px)效果是否相同，为什么？","question_answer":"不相同\n两个变换是有先后顺序的，是先转后移还是先移后转，比较容易比划出来\n从原理上来说，变换最后是用矩阵乘向量来运算的，矩阵乘法不具有交换律，因此M1*M2和M2*M1的结果是不同的\n1. 2.5分及以下：答错了，或者答对了猜的\n2. 3.0分：答对了，比划出来的\n3. 3.5分：答对了，原理也说出来了\n4. 4.0分：为什么要用矩阵来实现变换也说得出来","i18n_question_answer":"不相同\n两个变换是有先后顺序的，是先转后移还是先移后转，比较容易比划出来\n从原理上来说，变换最后是用矩阵乘向量来运算的，矩阵乘法不具有交换律，因此M1*M2和M2*M1的结果是不同的\n1. 2.5分及以下：答错了，或者答对了猜的\n2. 3.0分：答对了，比划出来的\n3. 3.5分：答对了，原理也说出来了\n4. 4.0分：为什么要用矩阵来实现变换也说得出来","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239917180452","question_title":"post 请求有哪几种常见类型，在常见node框架中如何处理","i18n_question_title":"post 请求有哪几种常见类型，在常见node框架中如何处理","question_skill_list":[{"name":"Node.js","i18n_name":"Node.js","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"post 请求有哪几种常见类型，在常见node框架中如何处理","i18n_question_description":"post 请求有哪几种常见类型，在常见node框架中如何处理","question_answer":"按照 content-type 分为常见的四种：\n1. `application/x-www-form-urlencoded`, 即 a=b&c=d 的形式\n2. `application/json`，即 json 字符串的形式\n3. `multipart/form-data`，通常用于上传文件\n4. `application/xml`，即 xml 的形式，比较少见\n以 express 为例，\n前两种通过 bodyParse 中间件处理，然后通过 req.body 获取请求体；  \n第三种，可以通过 multer 模块处理请求体，然后通过 req.files 获取文件  \n第四种，可以获取原始字符串，拼接后转化为 json （比如利用 xml2json）再进行处理\n1. 2.5分及以下：前三种方式没有说全\n2. 3.0分：前三种方式说全，处理方法清楚\n3. 3.5分：知道第四种方式以及处理方法\n4. 4.0分：","i18n_question_answer":"按照 content-type 分为常见的四种：\n1. `application/x-www-form-urlencoded`, 即 a=b&c=d 的形式\n2. `application/json`，即 json 字符串的形式\n3. `multipart/form-data`，通常用于上传文件\n4. `application/xml`，即 xml 的形式，比较少见\n以 express 为例，\n前两种通过 bodyParse 中间件处理，然后通过 req.body 获取请求体；  \n第三种，可以通过 multer 模块处理请求体，然后通过 req.files 获取文件  \n第四种，可以获取原始字符串，拼接后转化为 json （比如利用 xml2json）再进行处理\n1. 2.5分及以下：前三种方式没有说全\n2. 3.0分：前三种方式说全，处理方法清楚\n3. 3.5分：知道第四种方式以及处理方法\n4. 4.0分：","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402307209485","question_title":"请问如何使用JS实现一个带并发限制的异步调度器？","i18n_question_title":"请问如何使用JS实现一个带并发限制的异步调度器？","question_skill_list":[{"name":"前端基础","i18n_name":"前端基础","nick_name":null,"description":null},{"name":"异步","i18n_name":"异步","nick_name":null,"description":null},{"name":"promise","i18n_name":"promise","nick_name":null,"description":null}],"score":null,"content":null,"question_description":null,"i18n_question_description":null,"question_answer":null,"i18n_question_answer":null,"status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445585932437028","question_title":"数组扁平化","i18n_question_title":"数组扁平化","question_skill_list":[{"name":"编码","i18n_name":"编码","nick_name":null,"description":null},{"name":"编程","i18n_name":"编程","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"> 实现一个函数，输入为一个数组，数组中的元素为整数或者数组，输出为扁平化后的数组\n如：`[1, [2, [ [3, 4], 5], 6], 7] => [1, 2, 3, 4, 5, 6, 7]`","i18n_question_description":"> 实现一个函数，输入为一个数组，数组中的元素为整数或者数组，输出为扁平化后的数组\n如：`[1, [2, [ [3, 4], 5], 6], 7] => [1, 2, 3, 4, 5, 6, 7]`","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"js\\n\"},{\"insert\":\" var data = [1, [2, [ [3, 4], 5], 6], 7];\\n\"},{\"insert\":\" function flat(data, result) {\\n\"},{\"insert\":\" var i, d, len;\\n\"},{\"insert\":\" for (i = 0, len = data.length; i < len; ++i) {\\n\"},{\"insert\":\" d = data[i];\\n\"},{\"insert\":\" if (typeof d === 'number') {\\n\"},{\"insert\":\" result.push(d);\\n\"},{\"insert\":\" } else {\\n\"},{\"insert\":\" flat(d, result);\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" var result = [];\\n\"},{\"insert\":\" flat(data, result);\\n\"},{\"insert\":\" console.log(result);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：没有思路，不会实现\\n\"},{\"insert\":\"2. 3.0分：给出一种实现方法\\n\"},{\"insert\":\"3. 3.5分：给出多种实现方法\\n\"},{\"insert\":\"4. 4.0分：\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"js\\n\"},{\"insert\":\" var data = [1, [2, [ [3, 4], 5], 6], 7];\\n\"},{\"insert\":\" function flat(data, result) {\\n\"},{\"insert\":\" var i, d, len;\\n\"},{\"insert\":\" for (i = 0, len = data.length; i < len; ++i) {\\n\"},{\"insert\":\" d = data[i];\\n\"},{\"insert\":\" if (typeof d === 'number') {\\n\"},{\"insert\":\" result.push(d);\\n\"},{\"insert\":\" } else {\\n\"},{\"insert\":\" flat(d, result);\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\"\\n\"},{\"insert\":\" var result = [];\\n\"},{\"insert\":\" flat(data, result);\\n\"},{\"insert\":\" console.log(result);\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：没有思路，不会实现\\n\"},{\"insert\":\"2. 3.0分：给出一种实现方法\\n\"},{\"insert\":\"3. 3.5分：给出多种实现方法\\n\"},{\"insert\":\"4. 4.0分：\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402308126989","question_title":"请谈一谈JAVAscript的作用域和this","i18n_question_title":"请谈一谈JAVAscript的作用域和this","question_skill_list":[{"name":"语言关键字","i18n_name":"语言关键字","nick_name":null,"description":null},{"name":"语言基础","i18n_name":"语言基础","nick_name":null,"description":null},{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"```\ninner = 'window';\nfunction say() {\n    console.log(inner);\n    console.log(this.inner);\n}\nvar obj1 = (function() {\n    var inner = '1-1';\n    return {\n        inner: '1-2',\n        say: function() {\n            console.log(inner);\n            console.log(this.inner);\n        }\n    }\n})();\nvar obj2 = (function() {\n    var inner = '2-1';\n    return {\n        inner: '2-2',\n        say: function() {\n            console.log(inner);\n            console.log(this.inner);\n        }\n    }\n})();\nsay();\nobj1.say();\nobj2.say();\nobj1.say = say;\nobj1.say();\nobj1.say = obj2.say;\nobj1.say();\n```","i18n_question_description":"```\ninner = 'window';\nfunction say() {\n    console.log(inner);\n    console.log(this.inner);\n}\nvar obj1 = (function() {\n    var inner = '1-1';\n    return {\n        inner: '1-2',\n        say: function() {\n            console.log(inner);\n            console.log(this.inner);\n        }\n    }\n})();\nvar obj2 = (function() {\n    var inner = '2-1';\n    return {\n        inner: '2-2',\n        say: function() {\n            console.log(inner);\n            console.log(this.inner);\n        }\n    }\n})();\nsay();\nobj1.say();\nobj2.say();\nobj1.say = say;\nobj1.say();\nobj1.say = obj2.say;\nobj1.say();\n```","question_answer":"```\nwindow\nwindow\n1-1\n1-2\n2-1\n2-2\nwindow\n1-2\n2-1\n1-2\n主要考察javascript的作用域和this指向。作用域是静态的，声明时确定；this是动态的，运行时确定。\n```\n回答正确可以给3分\n如果可以能给出具体的解释说明可以给3.5分","i18n_question_answer":"```\nwindow\nwindow\n1-1\n1-2\n2-1\n2-2\nwindow\n1-2\n2-1\n1-2\n主要考察javascript的作用域和this指向。作用域是静态的，声明时确定；this是动态的，运行时确定。\n```\n回答正确可以给3分\n如果可以能给出具体的解释说明可以给3.5分","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402307029261","question_title":"请描述 CSS margin 折叠问题","i18n_question_title":"请描述 CSS margin 折叠问题","question_skill_list":[{"name":"前端基础","i18n_name":"前端基础","nick_name":null,"description":null},{"name":"CSS","i18n_name":"CSS","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"a b 在页面中将如何展示？\n当 b 的margin-top 为 -20 时如何展示？\n<div class=\"a\"></div>\n<div class=\"b\"></div>\n.a {\n\t\theight: 100px;\n\t\tmargin-bottom: 10px;\n}\n.b {\n\t\theight: 100px;\n\t\tmargin-top: 20px;\n}","i18n_question_description":"a b 在页面中将如何展示？\n当 b 的margin-top 为 -20 时如何展示？\n<div class=\"a\"></div>\n<div class=\"b\"></div>\n.a {\n\t\theight: 100px;\n\t\tmargin-bottom: 10px;\n}\n.b {\n\t\theight: 100px;\n\t\tmargin-top: 20px;\n}","question_answer":"ab 间隔 20 px；\nab 重叠 10px；","i18n_question_answer":"ab 间隔 20 px；\nab 重叠 10px；","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239904581127","question_title":"js浮点运算","i18n_question_title":"js浮点运算","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"console.info(0.7+0.1)会得到什么","i18n_question_description":"console.info(0.7+0.1)会得到什么","question_answer":"输出0.799999\n3分 ：\n知道答案，大体了解原因\n3.5分：\n1.  js浮点计算失精度的经典问题，\n1.  延伸考察可以问下如何比较两个浮点数是否一致，\n1.  es6中引入了 Number.EPSILON\n1.  5.551115123125783e-17 < Number.EPSILON","i18n_question_answer":"输出0.799999\n3分 ：\n知道答案，大体了解原因\n3.5分：\n1.  js浮点计算失精度的经典问题，\n1.  延伸考察可以问下如何比较两个浮点数是否一致，\n1.  es6中引入了 Number.EPSILON\n1.  5.551115123125783e-17 < Number.EPSILON","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445585932404260","question_title":"数组flat函数设计","i18n_question_title":"数组flat函数设计","question_skill_list":[{"name":"es","i18n_name":"es","nick_name":null,"description":null},{"name":"基础算法","i18n_name":"基础算法","nick_name":null,"description":null},{"name":"编码","i18n_name":"编码","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"设计一个flat函数将如下数组arr=[1,2,['3',4,'5',[6,[7,8],9]]]输出为1,2,'3',4,'5',6,7,8,9。至少写出两种方法,要求不能改变数组中的原始数据类型","i18n_question_description":"设计一个flat函数将如下数组arr=[1,2,['3',4,'5',[6,[7,8],9]]]输出为1,2,'3',4,'5',6,7,8,9。至少写出两种方法,要求不能改变数组中的原始数据类型","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"方法一：递归\\n\"},{\"insert\":\"javascript\\n\"},{\"insert\":\"function flat(array) {\\n\"},{\"insert\":\" var result = [];\\n\"},{\"insert\":\" var each = function(arr) {\\n\"},{\"insert\":\" arr.forEach(item => {\\n\"},{\"insert\":\" if (item instanceof Array) {\\n\"},{\"insert\":\" each(item);\\n\"},{\"insert\":\" } else {\\n\"},{\"insert\":\" result.push(item);\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" });\\n\"},{\"insert\":\" };\\n\"},{\"insert\":\" each(array);\\n\"},{\"insert\":\" return result;\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\"var arr=[1,2,['3',4,'5',[6,[7,8],9]]];flat(arr).forEach(item=>{console.log(item)})\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"* 方法二：toString（格式转换），无法保证类型\\n\"},{\"insert\":\"javascript\\n\"},{\"insert\":\"Array.prototype.toString = function() {\\n\"},{\"insert\":\" return this.join(',');\\n\"},{\"insert\":\"};\\n\"},{\"insert\":\"console.log([1,2,[3,4,[5,6,7]]]+'');\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"* 方法三：Iterator\\n\"},{\"insert\":\"javascript\\n\"},{\"insert\":\"Array.prototype[Symbol.iterator] = function() {\\n\"},{\"insert\":\" let arr = [].concat(this),\\n\"},{\"insert\":\" index = 0;\\n\"},{\"insert\":\" let getFirst=function(array){\\n\"},{\"insert\":\" let first=array[0];\\n\"},{\"insert\":\" if(first instanceof Array){\\n\"},{\"insert\":\" return getFirst(array[0])\\n\"},{\"insert\":\" }else if(first!==undefined){\\n\"},{\"insert\":\" return array.shift()\\n\"},{\"insert\":\" }else{\\n\"},{\"insert\":\" return ''\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" return {\\n\"},{\"insert\":\" next: function() {\\n\"},{\"insert\":\" let item=getFirst(arr);\\n\"},{\"insert\":\" if(item){\\n\"},{\"insert\":\" return {\\n\"},{\"insert\":\" value:item,\\n\"},{\"insert\":\" done:false\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }else{\\n\"},{\"insert\":\" return {\\n\"},{\"insert\":\" done:true\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"var t=[1,2,['3',4,'5',[6,[7,8],9]]];\\n\"},{\"insert\":\"for(let i of t){console.log(i)}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：\\n\"},{\"insert\":\"只能写出一种方法及以下，通常只能写出递归\\n\"},{\"insert\":\"2. 3.0分：\\n\"},{\"insert\":\"能写出递归或者toString方法\\n\"},{\"insert\":\"3. 3.5分：\\n\"},{\"insert\":\"能写出Iterator或者Generator方法\\n\"},{\"insert\":\"4. 4.0分：\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"方法一：递归\\n\"},{\"insert\":\"javascript\\n\"},{\"insert\":\"function flat(array) {\\n\"},{\"insert\":\" var result = [];\\n\"},{\"insert\":\" var each = function(arr) {\\n\"},{\"insert\":\" arr.forEach(item => {\\n\"},{\"insert\":\" if (item instanceof Array) {\\n\"},{\"insert\":\" each(item);\\n\"},{\"insert\":\" } else {\\n\"},{\"insert\":\" result.push(item);\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" });\\n\"},{\"insert\":\" };\\n\"},{\"insert\":\" each(array);\\n\"},{\"insert\":\" return result;\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\"var arr=[1,2,['3',4,'5',[6,[7,8],9]]];flat(arr).forEach(item=>{console.log(item)})\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"* 方法二：toString（格式转换），无法保证类型\\n\"},{\"insert\":\"javascript\\n\"},{\"insert\":\"Array.prototype.toString = function() {\\n\"},{\"insert\":\" return this.join(',');\\n\"},{\"insert\":\"};\\n\"},{\"insert\":\"console.log([1,2,[3,4,[5,6,7]]]+'');\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"* 方法三：Iterator\\n\"},{\"insert\":\"javascript\\n\"},{\"insert\":\"Array.prototype[Symbol.iterator] = function() {\\n\"},{\"insert\":\" let arr = [].concat(this),\\n\"},{\"insert\":\" index = 0;\\n\"},{\"insert\":\" let getFirst=function(array){\\n\"},{\"insert\":\" let first=array[0];\\n\"},{\"insert\":\" if(first instanceof Array){\\n\"},{\"insert\":\" return getFirst(array[0])\\n\"},{\"insert\":\" }else if(first!==undefined){\\n\"},{\"insert\":\" return array.shift()\\n\"},{\"insert\":\" }else{\\n\"},{\"insert\":\" return ''\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" return {\\n\"},{\"insert\":\" next: function() {\\n\"},{\"insert\":\" let item=getFirst(arr);\\n\"},{\"insert\":\" if(item){\\n\"},{\"insert\":\" return {\\n\"},{\"insert\":\" value:item,\\n\"},{\"insert\":\" done:false\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }else{\\n\"},{\"insert\":\" return {\\n\"},{\"insert\":\" done:true\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"var t=[1,2,['3',4,'5',[6,[7,8],9]]];\\n\"},{\"insert\":\"for(let i of t){console.log(i)}\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：\\n\"},{\"insert\":\"只能写出一种方法及以下，通常只能写出递归\\n\"},{\"insert\":\"2. 3.0分：\\n\"},{\"insert\":\"能写出递归或者toString方法\\n\"},{\"insert\":\"3. 3.5分：\\n\"},{\"insert\":\"能写出Iterator或者Generator方法\\n\"},{\"insert\":\"4. 4.0分：\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445595297203748","question_title":"列表子元素顺序反转","i18n_question_title":"列表子元素顺序反转","question_skill_list":[{"name":"编码","i18n_name":"编码","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"编写一个函数将列表子元素顺序反转，如下所示：\n```html\n<ul id=\"target\">\n    1\n    2\n    3\n    4\n```\noutput：\n```html\n<ul id=\"target\">\n    4\n    3\n    2\n    1\n```","i18n_question_description":"编写一个函数将列表子元素顺序反转，如下所示：\n```html\n<ul id=\"target\">\n    1\n    2\n    3\n    4\n```\noutput：\n```html\n<ul id=\"target\">\n    4\n    3\n    2\n    1\n```","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"javascript\\n\"},{\"insert\":\"(function(){\\n\"},{\"insert\":\" var target = document.querySelector('#target');\\n\"},{\"insert\":\" var frag = document.createDocumentFragment();\\n\"},{\"insert\":\" for (var i = target.children.length - 1; i >= 0; --i) {\\n\"},{\"insert\":\" frag.appendChild(target.children[i]);\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" target.appendChild(frag);\\n\"},{\"insert\":\" })();\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：不了解原生dom操作，不知道如何反转dom列表\\n\"},{\"insert\":\"2. 3.0分：能使用document.querySelector搭配innerHTML进行内容复写，或者使用cloneNode的方式进行覆写操作。\\n\"},{\"insert\":\"3. 3.5分：能使用var i = target.children.length - 1; i >= 0; --i的方式进行倒序遍历节点\\n\"},{\"insert\":\"4. 4.0分：能使用document.createDocumentFragment();的方式进行dom操作优化，最后再完成target.appendChild(frag)，思路清晰无bug\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"javascript\\n\"},{\"insert\":\"(function(){\\n\"},{\"insert\":\" var target = document.querySelector('#target');\\n\"},{\"insert\":\" var frag = document.createDocumentFragment();\\n\"},{\"insert\":\" for (var i = target.children.length - 1; i >= 0; --i) {\\n\"},{\"insert\":\" frag.appendChild(target.children[i]);\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" target.appendChild(frag);\\n\"},{\"insert\":\" })();\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：不了解原生dom操作，不知道如何反转dom列表\\n\"},{\"insert\":\"2. 3.0分：能使用document.querySelector搭配innerHTML进行内容复写，或者使用cloneNode的方式进行覆写操作。\\n\"},{\"insert\":\"3. 3.5分：能使用var i = target.children.length - 1; i >= 0; --i的方式进行倒序遍历节点\\n\"},{\"insert\":\"4. 4.0分：能使用document.createDocumentFragment();的方式进行dom操作优化，最后再完成target.appendChild(frag)，思路清晰无bug\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null}],"BaseResp":{"StatusMessage":"SUCCESS","StatusCode":0,"Extra":null}},"message":"OK","special_case_code":0}
