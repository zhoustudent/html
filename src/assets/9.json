{"code":0,"success":true,"data":{"has_more":true,"page_token":"YDoiuEzJSFG80JHCIhAMlXHPeKlXT5LjRKVJSX/1Dik=","assessments_list":[{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445595297302052","question_title":"给定一个无序整形数组，找出其中连续出现的数字区间","i18n_question_title":"给定一个无序整形数组，找出其中连续出现的数字区间","question_skill_list":[{"name":"基础算法","i18n_name":"基础算法","nick_name":null,"description":null},{"name":"编码","i18n_name":"编码","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"给定一个无序整形数组，请设计一个算法找出其中连续出现的数字区间。\n```javascript\nvar list = [7,2,11,2,0,1,2,4,5,10,13,14,15]\nfunction summaryRanges(list){\n   // 补全代码\n}\nvar result = summaryRanges(list);\nconsole.log(result) // [\"0->2\", \"4->5\", \"7\", \"10->11\", \"13->15\"]\n```","i18n_question_description":"给定一个无序整形数组，请设计一个算法找出其中连续出现的数字区间。\n```javascript\nvar list = [7,2,11,2,0,1,2,4,5,10,13,14,15]\nfunction summaryRanges(list){\n   // 补全代码\n}\nvar result = summaryRanges(list);\nconsole.log(result) // [\"0->2\", \"4->5\", \"7\", \"10->11\", \"13->15\"]\n```","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"javascript\\n\"},{\"insert\":\"// leetcode 228: Summary Ranges\\n\"},{\"insert\":\"var summaryRanges = function (list) {\\n\"},{\"insert\":\" // 对数组进行排序和去重处理\\n\"},{\"insert\":\" var nums = [...new Set(list.sort((a, b) => a - b))]\\n\"},{\"insert\":\" // 用start记录一段连续数的开始\\n\"},{\"insert\":\" var len = nums.length;\\n\"},{\"insert\":\" if (len === 0) {\\n\"},{\"insert\":\" return [];\\n\"},{\"insert\":\" } else if (len == 1) {\\n\"},{\"insert\":\" return [nums[0].toString()];\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" var start = 0;\\n\"},{\"insert\":\" var result = [];\\n\"},{\"insert\":\" for (var i = 1; i < len; i++) {\\n\"},{\"insert\":\" if (nums[i] - nums[i - 1] == 1) {\\n\"},{\"insert\":\" continue;\\n\"},{\"insert\":\" } else {\\n\"},{\"insert\":\" // 根据连续数的个数，要么打印一个数，要么打印\\\"头->尾\\\"这样的格式\\n\"},{\"insert\":\" if (i - 1 == start) {\\n\"},{\"insert\":\" result.push(nums[start].toString());\\n\"},{\"insert\":\" } else {\\n\"},{\"insert\":\" result.push(nums[start] + \\\"->\\\" + nums[i - 1]);\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" start = i;\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" if (start == len - 1) {\\n\"},{\"insert\":\" result.push(nums[len - 1].toString());\\n\"},{\"insert\":\" } else {\\n\"},{\"insert\":\" result.push(nums[start] + \\\"->\\\" + nums[len - 1]);\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" return result;\\n\"},{\"insert\":\"};\\n\"},{\"insert\":\"var list = [7, 2, 11, 2, 0, 1, 2, 4, 5, 10, 13, 14, 15]\\n\"},{\"insert\":\"console.log(summaryRanges(list))\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"参考： http://huaren-it.com/thread/leetcode%E7%AC%AC228%E9%A2%98-summary-ranges/\\n\"},{\"insert\":\"1. 2.5分及以下：无任何思路，不知道如何计算连续数值区间\\n\"},{\"insert\":\"2. 3.0分：没有想到开始需要去除重复数字和排序可以提升检索质量\\n\"},{\"insert\":\"3. 3.5分：能完成基本的数组遍历和计数，能实现根据start完成nums[start] + \\\"->\\\" + nums[i - 1])\\n\"},{\"insert\":\"4. 4.0分：能完成所有代码，能考虑到[].length的边界情况，代码运行正常\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"javascript\\n\"},{\"insert\":\"// leetcode 228: Summary Ranges\\n\"},{\"insert\":\"var summaryRanges = function (list) {\\n\"},{\"insert\":\" // 对数组进行排序和去重处理\\n\"},{\"insert\":\" var nums = [...new Set(list.sort((a, b) => a - b))]\\n\"},{\"insert\":\" // 用start记录一段连续数的开始\\n\"},{\"insert\":\" var len = nums.length;\\n\"},{\"insert\":\" if (len === 0) {\\n\"},{\"insert\":\" return [];\\n\"},{\"insert\":\" } else if (len == 1) {\\n\"},{\"insert\":\" return [nums[0].toString()];\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" var start = 0;\\n\"},{\"insert\":\" var result = [];\\n\"},{\"insert\":\" for (var i = 1; i < len; i++) {\\n\"},{\"insert\":\" if (nums[i] - nums[i - 1] == 1) {\\n\"},{\"insert\":\" continue;\\n\"},{\"insert\":\" } else {\\n\"},{\"insert\":\" // 根据连续数的个数，要么打印一个数，要么打印\\\"头->尾\\\"这样的格式\\n\"},{\"insert\":\" if (i - 1 == start) {\\n\"},{\"insert\":\" result.push(nums[start].toString());\\n\"},{\"insert\":\" } else {\\n\"},{\"insert\":\" result.push(nums[start] + \\\"->\\\" + nums[i - 1]);\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" start = i;\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" if (start == len - 1) {\\n\"},{\"insert\":\" result.push(nums[len - 1].toString());\\n\"},{\"insert\":\" } else {\\n\"},{\"insert\":\" result.push(nums[start] + \\\"->\\\" + nums[len - 1]);\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" return result;\\n\"},{\"insert\":\"};\\n\"},{\"insert\":\"var list = [7, 2, 11, 2, 0, 1, 2, 4, 5, 10, 13, 14, 15]\\n\"},{\"insert\":\"console.log(summaryRanges(list))\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"参考： http://huaren-it.com/thread/leetcode%E7%AC%AC228%E9%A2%98-summary-ranges/\\n\"},{\"insert\":\"1. 2.5分及以下：无任何思路，不知道如何计算连续数值区间\\n\"},{\"insert\":\"2. 3.0分：没有想到开始需要去除重复数字和排序可以提升检索质量\\n\"},{\"insert\":\"3. 3.5分：能完成基本的数组遍历和计数，能实现根据start完成nums[start] + \\\"->\\\" + nums[i - 1])\\n\"},{\"insert\":\"4. 4.0分：能完成所有代码，能考虑到[].length的边界情况，代码运行正常\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239917229604","question_title":"react 中常见的性能优化策略及原理","i18n_question_title":"react 中常见的性能优化策略及原理","question_skill_list":[{"name":"渲染性能","i18n_name":"渲染性能","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"在使用 react 的过程中，有哪些常见的性能优化策略，这些策略的原理是什么？","i18n_question_description":"在使用 react 的过程中，有哪些常见的性能优化策略，这些策略的原理是什么？","question_answer":"1. 利用 shouldComponentUpdate 生命周期函数，加少不必要的 render （跳过 virtual dom diff 的过程）\n2. 数组中的元素使用 key 属性，提到 diff 效率，减少不必要的 dom 创建和销毁操作\n3. 纯函数组件（无状态组件），相比有状态组件（class），内存占用小\n4. Immutable Data，使用结构共享复用内存，且避免深度遍历比较（结合 shouldComponentUpdate）\n5. pure render\n1. 2.5分及以下：\n2. 3.0分：能说全以上5种方式及基本原理\n3. 3.5分：能提出以上5种方式之外的方案\n4. 4.0分：","i18n_question_answer":"1. 利用 shouldComponentUpdate 生命周期函数，加少不必要的 render （跳过 virtual dom diff 的过程）\n2. 数组中的元素使用 key 属性，提到 diff 效率，减少不必要的 dom 创建和销毁操作\n3. 纯函数组件（无状态组件），相比有状态组件（class），内存占用小\n4. Immutable Data，使用结构共享复用内存，且避免深度遍历比较（结合 shouldComponentUpdate）\n5. pure render\n1. 2.5分及以下：\n2. 3.0分：能说全以上5种方式及基本原理\n3. 3.5分：能提出以上5种方式之外的方案\n4. 4.0分：","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445587425560094","question_title":"Hive数据类型转换","i18n_question_title":"Hive数据类型转换","question_skill_list":[{"name":"简单编程题","i18n_name":"简单编程题","nick_name":null,"description":null},{"name":"编码","i18n_name":"编码","nick_name":null,"description":null},{"name":"编程","i18n_name":"编程","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"已知Hive中的数据类型分为基础类型和复合类型，如下：\n基础类型：int、float、string、char、string等\n复合类型：array、map、struct等\n基础类型不可分割，复合类型由基础类型加<、>组合而成\n例如：\n一个由字符串组成的数组 => array<string>\n一个key为字符串，值为整型的字典 => map<string, int>\n现要求定义如下函数\nfunction translate(types) {}\n实现如下效果\ncosnt typeList = [“map”, \"string\", \"array\", \"map\", \"int\", \"array\", \"double\"]\ntranslate(typeList) => map<string, array<map<int, array<double>>>>","i18n_question_description":"已知Hive中的数据类型分为基础类型和复合类型，如下：\n基础类型：int、float、string、char、string等\n复合类型：array、map、struct等\n基础类型不可分割，复合类型由基础类型加<、>组合而成\n例如：\n一个由字符串组成的数组 => array<string>\n一个key为字符串，值为整型的字典 => map<string, int>\n现要求定义如下函数\nfunction translate(types) {}\n实现如下效果\ncosnt typeList = [“map”, \"string\", \"array\", \"map\", \"int\", \"array\", \"double\"]\ntranslate(typeList) => map<string, array<map<int, array<double>>>>","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"将复合类型当做操作符，基础类型当做参数，实现基本的算术运算符解析\\n\"},{\"insert\":\"function translate (typeList: string[] = []) {\\n\"},{\"insert\":\"let result = '';\\n\"},{\"insert\":\"const stack: string[] = [];\\n\"},{\"insert\":\"const partition = (type: string, value: string) => `${type}<${value}>`;\\n\"},{\"insert\":\"typeList.reverse().forEach((item) => {\\n\"},{\"attributes\":{\"italic\":\"true\"},\"insert\":\"if\"},{\"insert\":\" (['map'].includes(item)) {\\n\"},{\"insert\":\"result = partition(item, `${stack.pop()},${result ? result : stack.pop()}`);\\n\"},{\"insert\":\"} \"},{\"attributes\":{\"italic\":\"true\"},\"insert\":\"else\"},{\"insert\":\" \"},{\"attributes\":{\"italic\":\"true\"},\"insert\":\"if\"},{\"insert\":\" (['array', 'struct'].includes(item)) {\\n\"},{\"insert\":\"result = partition(item, `${result ? result : stack.pop()}`);\\n\"},{\"insert\":\"} \"},{\"attributes\":{\"italic\":\"true\"},\"insert\":\"else\"},{\"insert\":\" {\\n\"},{\"insert\":\"stack.push(item);\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"});\\n\"},{\"attributes\":{\"italic\":\"true\"},\"insert\":\"if\"},{\"insert\":\" (stack.length) {\\n\"},{\"insert\":\"result = result ? '' : (stack.pop() || '');\\n\"},{\"insert\":\"}\\n\"},{\"attributes\":{\"italic\":\"true\"},\"insert\":\"return\"},{\"insert\":\" result;\\n\"},{\"insert\":\"};\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"2.5分及以下：没有思路\\n\"},{\"insert\":\"3.0分：能回答出基本思路\\n\"},{\"insert\":\"3.5分：实现算法，代码逻辑清晰\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"将复合类型当做操作符，基础类型当做参数，实现基本的算术运算符解析\\n\"},{\"insert\":\"function translate (typeList: string[] = []) {\\n\"},{\"insert\":\"let result = '';\\n\"},{\"insert\":\"const stack: string[] = [];\\n\"},{\"insert\":\"const partition = (type: string, value: string) => `${type}<${value}>`;\\n\"},{\"insert\":\"typeList.reverse().forEach((item) => {\\n\"},{\"attributes\":{\"italic\":\"true\"},\"insert\":\"if\"},{\"insert\":\" (['map'].includes(item)) {\\n\"},{\"insert\":\"result = partition(item, `${stack.pop()},${result ? result : stack.pop()}`);\\n\"},{\"insert\":\"} \"},{\"attributes\":{\"italic\":\"true\"},\"insert\":\"else\"},{\"insert\":\" \"},{\"attributes\":{\"italic\":\"true\"},\"insert\":\"if\"},{\"insert\":\" (['array', 'struct'].includes(item)) {\\n\"},{\"insert\":\"result = partition(item, `${result ? result : stack.pop()}`);\\n\"},{\"insert\":\"} \"},{\"attributes\":{\"italic\":\"true\"},\"insert\":\"else\"},{\"insert\":\" {\\n\"},{\"insert\":\"stack.push(item);\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"});\\n\"},{\"attributes\":{\"italic\":\"true\"},\"insert\":\"if\"},{\"insert\":\" (stack.length) {\\n\"},{\"insert\":\"result = result ? '' : (stack.pop() || '');\\n\"},{\"insert\":\"}\\n\"},{\"attributes\":{\"italic\":\"true\"},\"insert\":\"return\"},{\"insert\":\" result;\\n\"},{\"insert\":\"};\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"2.5分及以下：没有思路\\n\"},{\"insert\":\"3.0分：能回答出基本思路\\n\"},{\"insert\":\"3.5分：实现算法，代码逻辑清晰\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058255971649055","question_title":"同步代码改成异步的代码","i18n_question_title":"同步代码改成异步的代码","question_skill_list":null,"score":null,"content":null,"question_description":"<pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> a + b;\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getValue</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> add(a, b)\n}\n如果提供了一个 `asyncAdd` 的接口，如果升级 `getValue` 来使用这个接口呢？\n<pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncAdd</span>(<span class=\"hljs-params\">a, b, callback</span>) </span>{\n  doAsyncWork(a, b).then(<span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> callback(value));\n}\n \n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncGetValue</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =></span> asyncAdd(a, b, resolve))\n}\n进一步提问，如果有一批数据，需要调用 asyncAdd 来计算应该如何做呢？\n<pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">list</span> = [\n  {a: <span class=\"hljs-number\">1</span>, b: <span class=\"hljs-number\">2</span>},\n  {a: <span class=\"hljs-number\">100</span>, b: <span class=\"hljs-number\">200</span>},\n  {a: <span class=\"hljs-number\">11</span>, b: <span class=\"hljs-number\">21</span>},\n  {a: <span class=\"hljs-number\">31</span>, b: <span class=\"hljs-number\">41</span>},\n  {a: <span class=\"hljs-number\">41</span>, b: <span class=\"hljs-number\">51</span>}\n];\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncGetValues</span><span class=\"hljs-params\">(list, callback)</span> </span>{\n}\n再进一步提问，如果需要控制并发度，应该如何处理呢？\n<pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">list</span> = [\n  {a: <span class=\"hljs-number\">1</span>, b: <span class=\"hljs-number\">2</span>},\n  {a: <span class=\"hljs-number\">100</span>, b: <span class=\"hljs-number\">200</span>},\n  {a: <span class=\"hljs-number\">11</span>, b: <span class=\"hljs-number\">21</span>},\n  {a: <span class=\"hljs-number\">31</span>, b: <span class=\"hljs-number\">41</span>},\n  {a: <span class=\"hljs-number\">41</span>, b: <span class=\"hljs-number\">51</span>}\n];\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncGetValues</span><span class=\"hljs-params\">(list, maxConcurrent, callback)</span> </span>{\n}","i18n_question_description":"<pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> a + b;\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getValue</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> add(a, b)\n}\n如果提供了一个 `asyncAdd` 的接口，如果升级 `getValue` 来使用这个接口呢？\n<pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncAdd</span>(<span class=\"hljs-params\">a, b, callback</span>) </span>{\n  doAsyncWork(a, b).then(<span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> callback(value));\n}\n \n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncGetValue</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =></span> asyncAdd(a, b, resolve))\n}\n进一步提问，如果有一批数据，需要调用 asyncAdd 来计算应该如何做呢？\n<pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">list</span> = [\n  {a: <span class=\"hljs-number\">1</span>, b: <span class=\"hljs-number\">2</span>},\n  {a: <span class=\"hljs-number\">100</span>, b: <span class=\"hljs-number\">200</span>},\n  {a: <span class=\"hljs-number\">11</span>, b: <span class=\"hljs-number\">21</span>},\n  {a: <span class=\"hljs-number\">31</span>, b: <span class=\"hljs-number\">41</span>},\n  {a: <span class=\"hljs-number\">41</span>, b: <span class=\"hljs-number\">51</span>}\n];\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncGetValues</span><span class=\"hljs-params\">(list, callback)</span> </span>{\n}\n再进一步提问，如果需要控制并发度，应该如何处理呢？\n<pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">list</span> = [\n  {a: <span class=\"hljs-number\">1</span>, b: <span class=\"hljs-number\">2</span>},\n  {a: <span class=\"hljs-number\">100</span>, b: <span class=\"hljs-number\">200</span>},\n  {a: <span class=\"hljs-number\">11</span>, b: <span class=\"hljs-number\">21</span>},\n  {a: <span class=\"hljs-number\">31</span>, b: <span class=\"hljs-number\">41</span>},\n  {a: <span class=\"hljs-number\">41</span>, b: <span class=\"hljs-number\">51</span>}\n];\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncGetValues</span><span class=\"hljs-params\">(list, maxConcurrent, callback)</span> </span>{\n}","question_answer":"暂无\n3.0: 第一步\n3.5: 第二步\n4.0：第三步","i18n_question_answer":"暂无\n3.0: 第一步\n3.5: 第二步\n4.0：第三步","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916262948","question_title":"请给出以下代码的输出结果","i18n_question_title":"请给出以下代码的输出结果","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"nodejs 环境下，请给出以下代码的输出结果\n```javascript\nfunction A() {\n    console.log('a')\n}\nfunction B() {\n    console.log('b')\n}\nfunction C() {\n    console.log('c')\n}\nfunction D() {\n    console.log('d')\n}\nfunction E() {\n    console.log('e')\n}\nfunction F() {\n    console.log('f')\n}\nA()\nsetTimeout(B, 0)\nsetImmediate(C)\nprocess.nextTick(D)\nPromise.resolve().then(function() {\n    E()\n})\nF()\n```","i18n_question_description":"nodejs 环境下，请给出以下代码的输出结果\n```javascript\nfunction A() {\n    console.log('a')\n}\nfunction B() {\n    console.log('b')\n}\nfunction C() {\n    console.log('c')\n}\nfunction D() {\n    console.log('d')\n}\nfunction E() {\n    console.log('e')\n}\nfunction F() {\n    console.log('f')\n}\nA()\nsetTimeout(B, 0)\nsetImmediate(C)\nprocess.nextTick(D)\nPromise.resolve().then(function() {\n    E()\n})\nF()\n```","question_answer":"```javascript\na\nf\nd\ne\nb\nc\n```\n1. 2.5分及以下：\n2. 3.0分：知道 nextTick 在 setImmediate 前面，promise 在 setTimeout 前面，顺序基本正确（80%）\n3. 3.5分：答案完全正确\n4. 4.0分：","i18n_question_answer":"```javascript\na\nf\nd\ne\nb\nc\n```\n1. 2.5分及以下：\n2. 3.0分：知道 nextTick 在 setImmediate 前面，promise 在 setTimeout 前面，顺序基本正确（80%）\n3. 3.5分：答案完全正确\n4. 4.0分：","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402307242253","question_title":"请用代码实现数组随机排序","i18n_question_title":"请用代码实现数组随机排序","question_skill_list":[{"name":"算法","i18n_name":"算法","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"```JAVAscript\n  var arr=[1,2,3,4,5,6]\n  ```","i18n_question_description":"```JAVAscript\n  var arr=[1,2,3,4,5,6]\n  ```","question_answer":null,"i18n_question_answer":null,"status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445587425297950","question_title":"JavaScript实现对象深拷贝方法","i18n_question_title":"JavaScript实现对象深拷贝方法","question_skill_list":[{"name":"语言基础","i18n_name":"语言基础","nick_name":null,"description":null},{"name":"编码","i18n_name":"编码","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"编码实现JavaScript实现对象深拷贝","i18n_question_description":"编码实现JavaScript实现对象深拷贝","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"var clone = function(v) { \\n\"},{\"insert\":\" var o = v.constructor === Array ? [] : {}; \\n\"},{\"insert\":\" for (var i in v) { \\n\"},{\"insert\":\" o[i] = typeof v[i] === \\\"Object\\\" ? clone(v[i]) : v[i]; \\n\"},{\"insert\":\" } \\n\"},{\"insert\":\" return o; \\n\"},{\"insert\":\"} \\n\"},{\"insert\":\"1. 2.5分及以下：代码错误不得分 \\n\"},{\"insert\":\"2. 3.0分：代码完成正确\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"var clone = function(v) { \\n\"},{\"insert\":\" var o = v.constructor === Array ? [] : {}; \\n\"},{\"insert\":\" for (var i in v) { \\n\"},{\"insert\":\" o[i] = typeof v[i] === \\\"Object\\\" ? clone(v[i]) : v[i]; \\n\"},{\"insert\":\" } \\n\"},{\"insert\":\" return o; \\n\"},{\"insert\":\"} \\n\"},{\"insert\":\"1. 2.5分及以下：代码错误不得分 \\n\"},{\"insert\":\"2. 3.0分：代码完成正确\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034432331592533517","question_title":"如何初始化WebGL渲染上下文","i18n_question_title":"如何初始化WebGL渲染上下文","question_skill_list":[{"name":"编码","i18n_name":"编码","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"通过_________来时完成对WebGL渲染上下文的初始化。","i18n_question_description":"通过_________来时完成对WebGL渲染上下文的初始化。","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"var webgl = document.createElement('canvas').canvas.getContext('webgl');\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"var webgl = document.createElement('canvas').canvas.getContext('webgl');\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916361252","question_title":"说说前端优化？图片懒加载原理是什么？","i18n_question_title":"说说前端优化？图片懒加载原理是什么？","question_skill_list":[{"name":"渲染框架","i18n_name":"渲染框架","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"* 考察前端的一些优化方式\n* 图片懒加载原理","i18n_question_description":"* 考察前端的一些优化方式\n* 图片懒加载原理","question_answer":"1. 优化手段：雅虎的34条优化手段，比如：代码压缩、减少请求、cdn、缓存\n2. 图片懒加载原理：img标签设置占位属性(data-src)，存储真正的图片地址；原src设置占位图片地址；当图片(快)进入用户可视区域的时候进行地址替换；\n1. 2.5分及以下：不了解常见的前端优化手段\n2. 3.0分：了解常见的优化手段，并了解图片懒加载原理\n3. 3.5分：\n4. 4.0分：","i18n_question_answer":"1. 优化手段：雅虎的34条优化手段，比如：代码压缩、减少请求、cdn、缓存\n2. 图片懒加载原理：img标签设置占位属性(data-src)，存储真正的图片地址；原src设置占位图片地址；当图片(快)进入用户可视区域的时候进行地址替换；\n1. 2.5分及以下：不了解常见的前端优化手段\n2. 3.0分：了解常见的优化手段，并了解图片懒加载原理\n3. 3.5分：\n4. 4.0分：","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058255971911199","question_title":"react hooks","i18n_question_title":"react hooks","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"function Counter() {\n\t const [count, setCount] = useState(0);\n\t useEffect(() => {\n\t \t const id = setInterval(() => {\n\t \t \t setCount(count + 1);\n\t \t }, 1000);\n\t \t return () => clearInterval(id);\n\t }, []);\n\t return <h1>{count}</h1>;\n}\n1. count输出是啥 ？ 为什么？ 如何修改？\nfunction Counter() {\n\t const [count, setCount] = useState(0);\n\t const [step, setStep] = useState(1);\n\t useEffect(() => {\n\t \t const id = setInterval(() => {\n\t \t \t setCount(c => c + step);\n\t \t }, 1000);\n\t \t return () => clearInterval(id);\n\t }, [step]);\n\t return (\n\t \t <>\n\t \t \t <h1>{count}</h1>\n\t \t \t <input value={step} onChange={e => setStep(Number(e.target.value))} />\n\t \t </>\n\t );\n}\n2. count输出是啥？ 有啥问题吗？ 如何修改？\n3. step 不是一个state，而是一个props呢？\n4. useEffect 的deps，哪些是不需要传入的，默认是恒定值的，hooks eslint 也不会报错？","i18n_question_description":"function Counter() {\n\t const [count, setCount] = useState(0);\n\t useEffect(() => {\n\t \t const id = setInterval(() => {\n\t \t \t setCount(count + 1);\n\t \t }, 1000);\n\t \t return () => clearInterval(id);\n\t }, []);\n\t return <h1>{count}</h1>;\n}\n1. count输出是啥 ？ 为什么？ 如何修改？\nfunction Counter() {\n\t const [count, setCount] = useState(0);\n\t const [step, setStep] = useState(1);\n\t useEffect(() => {\n\t \t const id = setInterval(() => {\n\t \t \t setCount(c => c + step);\n\t \t }, 1000);\n\t \t return () => clearInterval(id);\n\t }, [step]);\n\t return (\n\t \t <>\n\t \t \t <h1>{count}</h1>\n\t \t \t <input value={step} onChange={e => setStep(Number(e.target.value))} />\n\t \t </>\n\t );\n}\n2. count输出是啥？ 有啥问题吗？ 如何修改？\n3. step 不是一个state，而是一个props呢？\n4. useEffect 的deps，哪些是不需要传入的，默认是恒定值的，hooks eslint 也不会报错？","question_answer":"1. 一直是1， 因为dep是[], react每次render只会执行一次这个effect，所以setInterval 每次执行的是 setCount(0 + 1);\n加个dep [count], 不好，这导致每次render都会重复 创建以及销毁一次interval\n\tuseEffect(() => {\n\t \t const id = setInterval(() => {\n\t \t \t setCount(c => c + step);\n\t \t }, 1000);\n\t \t return () => clearInterval(id);\n\t }, []);\n2. 输出是1，2，3...正确的，问题在每次修改step都需要重新创建销毁interval，利用useReducer\nfunction Counter() {\n\t const [state, dispatch] = useReducer(reducer, initialState);\n\t const { count, step } = state;\n\t useEffect(() => {\n\t \t const id = setInterval(() => {\n\t \t \t dispatch({ type: 'tick' });\n\t \t }, 1000);\n\t \t return () => clearInterval(id);\n\t }, [dispatch]);\n\t return (\n\t \t <>\n\t \t \t <h1>{count}</h1>\n\t \t \t <input value={step} onChange={e => {\n\t \t \t \t dispatch({\n\t \t \t \t \t type: 'step',\n\t \t \t \t \t step: Number(e.target.value)\n\t \t \t \t });\n\t \t \t }} />\n\t \t </>\n\t );\n}\nfunction reducer(state, action) {\n\t const { count, step } = state;\n\t if (action.type === 'tick') {\n\t \t return { count: count + step, step };\n\t } else if (action.type === 'step') {\n\t \t return { count, step: action.step };\n\t } else {\n\t \t throw new Error();\n\t }\n}\nconst initialState = {\n\t count: 0,\n\t step: 1,\n};\n3. 把reduce funciton放入 fc中。\n4. useReducer的 dispatch，setState, useRef的返回值","i18n_question_answer":"1. 一直是1， 因为dep是[], react每次render只会执行一次这个effect，所以setInterval 每次执行的是 setCount(0 + 1);\n加个dep [count], 不好，这导致每次render都会重复 创建以及销毁一次interval\n\tuseEffect(() => {\n\t \t const id = setInterval(() => {\n\t \t \t setCount(c => c + step);\n\t \t }, 1000);\n\t \t return () => clearInterval(id);\n\t }, []);\n2. 输出是1，2，3...正确的，问题在每次修改step都需要重新创建销毁interval，利用useReducer\nfunction Counter() {\n\t const [state, dispatch] = useReducer(reducer, initialState);\n\t const { count, step } = state;\n\t useEffect(() => {\n\t \t const id = setInterval(() => {\n\t \t \t dispatch({ type: 'tick' });\n\t \t }, 1000);\n\t \t return () => clearInterval(id);\n\t }, [dispatch]);\n\t return (\n\t \t <>\n\t \t \t <h1>{count}</h1>\n\t \t \t <input value={step} onChange={e => {\n\t \t \t \t dispatch({\n\t \t \t \t \t type: 'step',\n\t \t \t \t \t step: Number(e.target.value)\n\t \t \t \t });\n\t \t \t }} />\n\t \t </>\n\t );\n}\nfunction reducer(state, action) {\n\t const { count, step } = state;\n\t if (action.type === 'tick') {\n\t \t return { count: count + step, step };\n\t } else if (action.type === 'step') {\n\t \t return { count, step: action.step };\n\t } else {\n\t \t throw new Error();\n\t }\n}\nconst initialState = {\n\t count: 0,\n\t step: 1,\n};\n3. 把reduce funciton放入 fc中。\n4. useReducer的 dispatch，setState, useRef的返回值","status_end_time":null,"assessment_create_time":null}],"BaseResp":{"StatusMessage":"SUCCESS","StatusCode":0,"Extra":null}},"message":"OK","special_case_code":0}
