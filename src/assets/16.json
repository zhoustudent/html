{"code":0,"success":true,"data":{"has_more":true,"page_token":"WWatK4bZvsNh0JkiNZ0tNKOSQ4bgPqWH9MrpPZTWnjA=","assessments_list":[{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445596262680094","question_title":"查找弹幕中的某个时间点","i18n_question_title":"查找弹幕中的某个时间点","question_skill_list":[{"name":"基础算法","i18n_name":"基础算法","nick_name":null,"description":null},{"name":"编码","i18n_name":"编码","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"目前视频网站都支持了弹幕 假设一个视频有很多的弹幕 并且格式定义如下:\\[{time: ..., content: ...}\\]\n那么如何快速定位到某个时间点的弹幕？","i18n_question_description":"目前视频网站都支持了弹幕 假设一个视频有很多的弹幕 并且格式定义如下:\\[{time: ..., content: ...}\\]\n那么如何快速定位到某个时间点的弹幕？","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"二分查找法\\n\"},{\"insert\":\"参考代码\\n\"},{\"insert\":\"```\\n\"},{\"insert\":\" function binary_search(arr, key) {\\n\"},{\"insert\":\" var low = 0,\\n\"},{\"insert\":\" high = arr.length - 1;\\n\"},{\"insert\":\" while(low <= high){\\n\"},{\"insert\":\" var mid = parseInt((high + low) / 2);\\n\"},{\"insert\":\" if(key == arr[mid]){\\n\"},{\"insert\":\" return mid;\\n\"},{\"insert\":\" }else if(key > arr[mid]){\\n\"},{\"insert\":\" low = mid + 1;\\n\"},{\"insert\":\" }else if(key < arr[mid]){\\n\"},{\"insert\":\" high = mid -1;\\n\"},{\"insert\":\" }else{\\n\"},{\"insert\":\" return -1;\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" };\\n\"},{\"insert\":\"````\\n\"},{\"insert\":\"1. 2.5分及以下：\\n\"},{\"insert\":\"想不到二分查找\\n\"},{\"insert\":\"2. 3.0分：\\n\"},{\"insert\":\"可以想到二分查找 并能用代码实现\\n\"},{\"insert\":\"3. 3.5分：\\n\"},{\"insert\":\"代码写的没有问题\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"二分查找法\\n\"},{\"insert\":\"参考代码\\n\"},{\"insert\":\"```\\n\"},{\"insert\":\" function binary_search(arr, key) {\\n\"},{\"insert\":\" var low = 0,\\n\"},{\"insert\":\" high = arr.length - 1;\\n\"},{\"insert\":\" while(low <= high){\\n\"},{\"insert\":\" var mid = parseInt((high + low) / 2);\\n\"},{\"insert\":\" if(key == arr[mid]){\\n\"},{\"insert\":\" return mid;\\n\"},{\"insert\":\" }else if(key > arr[mid]){\\n\"},{\"insert\":\" low = mid + 1;\\n\"},{\"insert\":\" }else if(key < arr[mid]){\\n\"},{\"insert\":\" high = mid -1;\\n\"},{\"insert\":\" }else{\\n\"},{\"insert\":\" return -1;\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" };\\n\"},{\"insert\":\"````\\n\"},{\"insert\":\"1. 2.5分及以下：\\n\"},{\"insert\":\"想不到二分查找\\n\"},{\"insert\":\"2. 3.0分：\\n\"},{\"insert\":\"可以想到二分查找 并能用代码实现\\n\"},{\"insert\":\"3. 3.5分：\\n\"},{\"insert\":\"代码写的没有问题\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402307094797","question_title":"请简述js浏览器事件循环机制","i18n_question_title":"请简述js浏览器事件循环机制","question_skill_list":[{"name":"事件","i18n_name":"事件","nick_name":null,"description":null},{"name":"浏览器","i18n_name":"浏览器","nick_name":null,"description":null},{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":null,"i18n_question_description":null,"question_answer":"浏览器 Event Loop 是 HTML 中定义的规范，Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。\nJS 调用栈\nJS 调用栈是一种后进先出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。\n同步任务、异步任务\nJavaScript 单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。\nEvent Loop\n调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环。\n定时器\n定时器会开启一条定时器触发线程来触发计时，定时器会在等待了指定的时间后将事件放入到任务队列中等待读取到主线程执行。定时器指定的延时毫秒数其实并不准确，因为定时器只是在到了指定的时间时将事件放入到任务队列中，必须要等到同步的任务和现有的任务队列中的事件全部执行完成之后，才会去读取定时器的事件到主线程执行，中间可能会存在耗时比较久的任务，那么就不可能保证在指定的时间执行。\n宏任务(macro-task)、微任务(micro-task)\n除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。micro-task包括：process.nextTick, Promises, Object.observe, MutationObserver。事件循环中，JavaScript 引擎会把整个 script 代码当成一个宏任务执行，执行完成之后，再检测本次循环中是否寻在微任务，存在的话就依次从微任务的任务队列中读取执行完所有的微任务，再读取宏任务的任务队列中的任务执行，再执行所有的微任务，如此循环。JS 的执行顺序就是每次事件循环中的宏任务-微任务。","i18n_question_answer":"浏览器 Event Loop 是 HTML 中定义的规范，Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。\nJS 调用栈\nJS 调用栈是一种后进先出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。\n同步任务、异步任务\nJavaScript 单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。\nEvent Loop\n调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环。\n定时器\n定时器会开启一条定时器触发线程来触发计时，定时器会在等待了指定的时间后将事件放入到任务队列中等待读取到主线程执行。定时器指定的延时毫秒数其实并不准确，因为定时器只是在到了指定的时间时将事件放入到任务队列中，必须要等到同步的任务和现有的任务队列中的事件全部执行完成之后，才会去读取定时器的事件到主线程执行，中间可能会存在耗时比较久的任务，那么就不可能保证在指定的时间执行。\n宏任务(macro-task)、微任务(micro-task)\n除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。micro-task包括：process.nextTick, Promises, Object.observe, MutationObserver。事件循环中，JavaScript 引擎会把整个 script 代码当成一个宏任务执行，执行完成之后，再检测本次循环中是否寻在微任务，存在的话就依次从微任务的任务队列中读取执行完所有的微任务，再读取宏任务的任务队列中的任务执行，再执行所有的微任务，如此循环。JS 的执行顺序就是每次事件循环中的宏任务-微任务。","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058255971747359","question_title":"box-sizing 实践","i18n_question_title":"box-sizing 实践","question_skill_list":[{"name":"CSS","i18n_name":"CSS","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      .box {\n        width: 10px;\n        height: 10px;\n        border: 1px solid red;\n        margin: 2px;\n        padding: 2px;\n        background: blue;\n      }\n      #borderBox {\n        box-sizing: border-box;\n      }\n      #contentBox {\n        box-sizing: content-box;\n      }\n    </style>\n  </head>\n  <body>\n    <div>请问下面两个 div 元素，蓝色区域的宽高各是多少像素？</div>\n    <div id=\"borderBox\" class=\"box\"></div>\n    <div id=\"contentBox\" class=\"box\"></div>\n  </body>\n</html>","i18n_question_description":"<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      .box {\n        width: 10px;\n        height: 10px;\n        border: 1px solid red;\n        margin: 2px;\n        padding: 2px;\n        background: blue;\n      }\n      #borderBox {\n        box-sizing: border-box;\n      }\n      #contentBox {\n        box-sizing: content-box;\n      }\n    </style>\n  </head>\n  <body>\n    <div>请问下面两个 div 元素，蓝色区域的宽高各是多少像素？</div>\n    <div id=\"borderBox\" class=\"box\"></div>\n    <div id=\"contentBox\" class=\"box\"></div>\n  </body>\n</html>","question_answer":"borderBox：10px(width) - 1px(border) * 2 = 8px \ncontentBox 10px(width) + 2px(padding) *2 = 14px\n答题要点：除了验证候选人是否真正了解 box-sizing 之外，也考察候选人是否了解 background 会影响元素的 padding 区域，而不影响 margin 区域这个特点\n盒模型解释正确的 2.5 分，不正确 2 分\n答案全部正确的 3 分","i18n_question_answer":"borderBox：10px(width) - 1px(border) * 2 = 8px \ncontentBox 10px(width) + 2px(padding) *2 = 14px\n答题要点：除了验证候选人是否真正了解 box-sizing 之外，也考察候选人是否了解 background 会影响元素的 padding 区域，而不影响 margin 区域这个特点\n盒模型解释正确的 2.5 分，不正确 2 分\n答案全部正确的 3 分","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239915836964","question_title":"移动开发手势事件","i18n_question_title":"移动开发手势事件","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"fastclick产生的缘由是什么？为什么需要这个?","i18n_question_description":"fastclick产生的缘由是什么？为什么需要这个?","question_answer":"解决200ms延迟，提升响应速度\n3分：了解fastclick产生得原因\n3.5分：了解点击穿透问题，并且了解解决方案","i18n_question_answer":"解决200ms延迟，提升响应速度\n3分：了解fastclick产生得原因\n3.5分：了解点击穿透问题，并且了解解决方案","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402307799309","question_title":"如何实现同域跨标签通信？","i18n_question_title":"如何实现同域跨标签通信？","question_skill_list":[{"name":"浏览器机制","i18n_name":"浏览器机制","nick_name":null,"description":null},{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"如何实现同域跨标签通信？","i18n_question_description":"如何实现同域跨标签通信？","question_answer":"1.  利用localstorage\n```javascript\nwindow.addEventListener('storage', function (event) {\n  console.log(event.key, event.newValue);\n});\n```\n2.  写个定时器，不断检查 Cookies 的变化\n在页面A设置一个使用 setInterval 定时器不断刷新，检查 Cookies 的值是否发生变化，如果变化就进行刷新的操作。\n由于 Cookies 是在同域可读的，所以在页面 B 审核的时候改变 Cookies 的值，页面 A 自然是可以拿到的。\n这样做确实可以实现我想要的功能，但是这样的方法相当浪费资源。虽然在这个性能过盛的时代，浪费不浪费也感觉不出来，但是这种实现方案，确实不够优(zhāng)雅（bī）\n1. 2.5分及以下：\n只能说出cookie或没有思路\n2. 3.0分：\n能说出localstorage和cookie，并作出对比\n3. 3.5分：\n4. 4.0分：","i18n_question_answer":"1.  利用localstorage\n```javascript\nwindow.addEventListener('storage', function (event) {\n  console.log(event.key, event.newValue);\n});\n```\n2.  写个定时器，不断检查 Cookies 的变化\n在页面A设置一个使用 setInterval 定时器不断刷新，检查 Cookies 的值是否发生变化，如果变化就进行刷新的操作。\n由于 Cookies 是在同域可读的，所以在页面 B 审核的时候改变 Cookies 的值，页面 A 自然是可以拿到的。\n这样做确实可以实现我想要的功能，但是这样的方法相当浪费资源。虽然在这个性能过盛的时代，浪费不浪费也感觉不出来，但是这种实现方案，确实不够优(zhāng)雅（bī）\n1. 2.5分及以下：\n只能说出cookie或没有思路\n2. 3.0分：\n能说出localstorage和cookie，并作出对比\n3. 3.5分：\n4. 4.0分：","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058255975712292","question_title":"H5直播技术的了解","i18n_question_title":"H5直播技术的了解","question_skill_list":[{"name":"HTML","i18n_name":"HTML","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"简要描述对H5直播技术的了解，如常用的直播协议，各自特征，以及音视频流的处理","i18n_question_description":"简要描述对H5直播技术的了解，如常用的直播协议，各自特征，以及音视频流的处理","question_answer":"常用的直播协议有很多种，比如 RTMP，HLS，HTTP-FLV。\n不过，最常用的还是 HLS 协议，因为支持度高，技术简单，但是延迟非常严重\nHLS协议---HLS 由两部分构成，一个是 .m3u8 文件，一个是 .ts 视频文件（TS 是视频文件格式的一种）。整个过程是，浏览器会首先去请求 .m3u8 的索引文件，然后解析 m3u8，找出对应的 .ts 文件链接，并开始下载\n他的使用方式为\n```\n<video controls autoplay>  \n    <source src=\"http://devimages.apple.com/iphone/samples/bipbop/masterplaylist.m3u8\" type=\"application/vnd.apple.mpegurl\" /> \n    <p class=\"warning\">Your browser does not support HTML5 video.\n  \n</video>\n```\n直接可以将 m3u8 写进 src 中，然后交由浏览器自己去解析,我们也可以采取 fetch 来手动解析并获取相关文件。HLS 详细版的内容比上面的简版多了一个 playlist，也可以叫做 master。在 master 中，会根据网络段实现设置好不同的 m3u8 文件，比如，3G/4G/wifi 网速等\n比如一个master文件中的内容为：\n```\n#EXTM3U\n#EXT-X-VERSION:6\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=2855600,CODECS=\"avc1.4d001f,mp4a.40.2\",RESOLUTION=960x540\nlive/medium.m3u8\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=5605600,CODECS=\"avc1.640028,mp4a.40.2\",RESOLUTION=1280x720\nlive/high.m3u8\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=1755600,CODECS=\"avc1.42001f,mp4a.40.2\",RESOLUTION=640x360\nlive/low.m3u8\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=545600,CODECS=\"avc1.42001e,mp4a.40.2\",RESOLUTION=416x234\nlive/cellular.m3u8\n```\n假如这里选择 high.m3u8 文件，那么，里面内容为\n```\n#EXTM3U\n#EXT-X-VERSION:6\n#EXT-X-TARGETDURATION:10\n#EXT-X-MEDIA-SEQUENCE:26\n#EXTINF:9.901,\nhttp://media.example.com/wifi/segment26.ts\n#EXTINF:9.901,\nhttp://media.example.com/wifi/segment27.ts\n#EXTINF:9.501,\nhttp://media.example.com/wifi/segment28.ts\n```\n其中以 ts 结尾的链接就是我们在直播中真正需要播放的视频文件。该第二级的 m3u8 文件也可以叫做 media 文件\nRTMP---全称为：Real-Time Messaging Protocol。它是基于 FLV 格式进行开发的\n在现在设备中，由于 FLV 的不支持，基本上 RTMP 协议在 Web 中，根本用不到。不过，由于 MSE（MediaSource Extensions）的出现，在 Web 上直接接入 RTMP 也不是不可能的。基本思路是根据 WebSocket 直接建立长连接进行数据的交流和监听\nRTMP 内部是借由 TCP 长连接协议传输相关数据，所以，它的延时性非常低。并且，该协议灵活性非常好（所以，也很复杂），它可以根据 message stream ID 传输数据，也可以根据 chunk stream ID 传递数据。两者都可以起到流的划分作用。流的内容也主要分为：视频，音频，相关协议包等。\n前端音视频流的处理主要涉及到MSE，包括一系列API：Media Source，Source Buffer 等，使使开发者可以直接提供 media stream\n```\n// 获取流和处理流简单实例\nvar vidElement = document.querySelector('video');\nif (window.MediaSource) {\n  var mediaSource = new MediaSource();\n  vidElement.src = URL.createObjectURL(mediaSource);\n  mediaSource.addEventListener('sourceopen', sourceOpen);\n} else {\n  console.log(\"The Media Source Extensions API is not supported.\")\n}\nfunction sourceOpen(e) {\n  URL.revokeObjectURL(vidElement.src);\n  var mime = 'video/webm; codecs=\"opus, vp9\"';\n  var mediaSource = e.target;\n  var sourceBuffer = mediaSource.addSourceBuffer(mime);\n  var videoUrl = 'droid.webm';\n  fetch(videoUrl)\n    .then(function(response) {\n      return response.arrayBuffer();\n    })\n    .then(function(arrayBuffer) {\n      sourceBuffer.addEventListener('updateend', function(e) {\n        if (!sourceBuffer.updating && mediaSource.readyState === 'open') {\n          mediaSource.endOfStream();\n        }\n      });\n      sourceBuffer.appendBuffer(arrayBuffer);\n    });\n}\n```\n1. 2.5分及以下：对于直播还没有做过了解\n2. 3.0分：知道基本常用的直播协议和基本原理\n3. 3.5分：满足3分基础上，对于MSE的基本用法有过了解和实际经验\n4. 4.0分：可以详细清晰的进行基本的流处理和实践经验","i18n_question_answer":"常用的直播协议有很多种，比如 RTMP，HLS，HTTP-FLV。\n不过，最常用的还是 HLS 协议，因为支持度高，技术简单，但是延迟非常严重\nHLS协议---HLS 由两部分构成，一个是 .m3u8 文件，一个是 .ts 视频文件（TS 是视频文件格式的一种）。整个过程是，浏览器会首先去请求 .m3u8 的索引文件，然后解析 m3u8，找出对应的 .ts 文件链接，并开始下载\n他的使用方式为\n```\n<video controls autoplay>  \n    <source src=\"http://devimages.apple.com/iphone/samples/bipbop/masterplaylist.m3u8\" type=\"application/vnd.apple.mpegurl\" /> \n    <p class=\"warning\">Your browser does not support HTML5 video.\n  \n</video>\n```\n直接可以将 m3u8 写进 src 中，然后交由浏览器自己去解析,我们也可以采取 fetch 来手动解析并获取相关文件。HLS 详细版的内容比上面的简版多了一个 playlist，也可以叫做 master。在 master 中，会根据网络段实现设置好不同的 m3u8 文件，比如，3G/4G/wifi 网速等\n比如一个master文件中的内容为：\n```\n#EXTM3U\n#EXT-X-VERSION:6\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=2855600,CODECS=\"avc1.4d001f,mp4a.40.2\",RESOLUTION=960x540\nlive/medium.m3u8\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=5605600,CODECS=\"avc1.640028,mp4a.40.2\",RESOLUTION=1280x720\nlive/high.m3u8\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=1755600,CODECS=\"avc1.42001f,mp4a.40.2\",RESOLUTION=640x360\nlive/low.m3u8\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=545600,CODECS=\"avc1.42001e,mp4a.40.2\",RESOLUTION=416x234\nlive/cellular.m3u8\n```\n假如这里选择 high.m3u8 文件，那么，里面内容为\n```\n#EXTM3U\n#EXT-X-VERSION:6\n#EXT-X-TARGETDURATION:10\n#EXT-X-MEDIA-SEQUENCE:26\n#EXTINF:9.901,\nhttp://media.example.com/wifi/segment26.ts\n#EXTINF:9.901,\nhttp://media.example.com/wifi/segment27.ts\n#EXTINF:9.501,\nhttp://media.example.com/wifi/segment28.ts\n```\n其中以 ts 结尾的链接就是我们在直播中真正需要播放的视频文件。该第二级的 m3u8 文件也可以叫做 media 文件\nRTMP---全称为：Real-Time Messaging Protocol。它是基于 FLV 格式进行开发的\n在现在设备中，由于 FLV 的不支持，基本上 RTMP 协议在 Web 中，根本用不到。不过，由于 MSE（MediaSource Extensions）的出现，在 Web 上直接接入 RTMP 也不是不可能的。基本思路是根据 WebSocket 直接建立长连接进行数据的交流和监听\nRTMP 内部是借由 TCP 长连接协议传输相关数据，所以，它的延时性非常低。并且，该协议灵活性非常好（所以，也很复杂），它可以根据 message stream ID 传输数据，也可以根据 chunk stream ID 传递数据。两者都可以起到流的划分作用。流的内容也主要分为：视频，音频，相关协议包等。\n前端音视频流的处理主要涉及到MSE，包括一系列API：Media Source，Source Buffer 等，使使开发者可以直接提供 media stream\n```\n// 获取流和处理流简单实例\nvar vidElement = document.querySelector('video');\nif (window.MediaSource) {\n  var mediaSource = new MediaSource();\n  vidElement.src = URL.createObjectURL(mediaSource);\n  mediaSource.addEventListener('sourceopen', sourceOpen);\n} else {\n  console.log(\"The Media Source Extensions API is not supported.\")\n}\nfunction sourceOpen(e) {\n  URL.revokeObjectURL(vidElement.src);\n  var mime = 'video/webm; codecs=\"opus, vp9\"';\n  var mediaSource = e.target;\n  var sourceBuffer = mediaSource.addSourceBuffer(mime);\n  var videoUrl = 'droid.webm';\n  fetch(videoUrl)\n    .then(function(response) {\n      return response.arrayBuffer();\n    })\n    .then(function(arrayBuffer) {\n      sourceBuffer.addEventListener('updateend', function(e) {\n        if (!sourceBuffer.updating && mediaSource.readyState === 'open') {\n          mediaSource.endOfStream();\n        }\n      });\n      sourceBuffer.appendBuffer(arrayBuffer);\n    });\n}\n```\n1. 2.5分及以下：对于直播还没有做过了解\n2. 3.0分：知道基本常用的直播协议和基本原理\n3. 3.5分：满足3分基础上，对于MSE的基本用法有过了解和实际经验\n4. 4.0分：可以详细清晰的进行基本的流处理和实践经验","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916148260","question_title":"如何实现一个支持私有（独立作用域或命名空间）的事件中心？","i18n_question_title":"如何实现一个支持私有（独立作用域或命名空间）的事件中心？","question_skill_list":[{"name":"工程构建","i18n_name":"工程构建","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"如题，使用时类似于\n// 支持每次实例化产生一个独立的事件中心，也就是说 ec1 与 ec2 是互不影响的\nvar ec = eventCenter();       \nec.on('toutiao', () => {\n  console.log('ttt');\n});\nsetTimeout(() => {\n  ec.emit('toutiao');    \n}, 5000);\n然后 5s 之后就显示 ttt 了","i18n_question_description":"如题，使用时类似于\n// 支持每次实例化产生一个独立的事件中心，也就是说 ec1 与 ec2 是互不影响的\nvar ec = eventCenter();       \nec.on('toutiao', () => {\n  console.log('ttt');\n});\nsetTimeout(() => {\n  ec.emit('toutiao');    \n}, 5000);\n然后 5s 之后就显示 ttt 了","question_answer":"核心思路就是内部要有一个事件队列，并且这个队列是私有的，然后每次有人 emit（派发）事件，\n就去队列中查找是否有相应事件的函数。如果有，执行就好。\n具体代码的例子，我写了一个简单的版本，\n1. 2.5分及以下：介绍了事件中心的概念，介绍了很多接口，比如 on、once、off 之类的接口，但是无法实现；\n2. 3.0分：能够回答出具体实现；\n3. 3.5分：能够介绍出可能存在的问题，比如内部如何处理 on（订阅事件，每次有事件时执行）、once（只订阅一次事件），最简单是内部两个队列分别存储；\n4. 4.0分：能够给出更多的建议或者更好的实现；","i18n_question_answer":"核心思路就是内部要有一个事件队列，并且这个队列是私有的，然后每次有人 emit（派发）事件，\n就去队列中查找是否有相应事件的函数。如果有，执行就好。\n具体代码的例子，我写了一个简单的版本，\n1. 2.5分及以下：介绍了事件中心的概念，介绍了很多接口，比如 on、once、off 之类的接口，但是无法实现；\n2. 3.0分：能够回答出具体实现；\n3. 3.5分：能够介绍出可能存在的问题，比如内部如何处理 on（订阅事件，每次有事件时执行）、once（只订阅一次事件），最简单是内部两个队列分别存储；\n4. 4.0分：能够给出更多的建议或者更好的实现；","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239915820580","question_title":"javascript异步加载","i18n_question_title":"javascript异步加载","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null},{"name":"HTML","i18n_name":"HTML","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"js延迟加载的方式有哪些？他们的区别是什么","i18n_question_description":"js延迟加载的方式有哪些？他们的区别是什么","question_answer":"```\n<script async src=\"script.js\"></script>\n```\n有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。\n```\n<script defer src=\"myscript.js\"></script>\n```\n有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。\n3分：  本题答对 3分 \n没有更高的分数","i18n_question_answer":"```\n<script async src=\"script.js\"></script>\n```\n有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。\n```\n<script defer src=\"myscript.js\"></script>\n```\n有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。\n3分：  本题答对 3分 \n没有更高的分数","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7034445587425396254","question_title":"判断一个字符串是否是回文字符串","i18n_question_title":"判断一个字符串是否是回文字符串","question_skill_list":[{"name":"编码","i18n_name":"编码","nick_name":null,"description":null},{"name":"编程","i18n_name":"编程","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"判断一个字符串是否是回文字符串，回文字符串是对称字符串的形式，例如：did，eve, dad, level","i18n_question_description":"判断一个字符串是否是回文字符串，回文字符串是对称字符串的形式，例如：did，eve, dad, level","question_answer":"{\"0\":{\"ops\":[{\"insert\":\"\\n\"},{\"insert\":\"function isPalindrome(str){\\n\"},{\"insert\":\" var i, len = str.length;\\n\"},{\"insert\":\" for(i=0; i<len/2; i++){\\n\"},{\"insert\":\" if (str[i]!== str[len -1 -i])\\n\"},{\"insert\":\" return false;\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" return true;\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"> isPalindrome('madam')\\n\"},{\"insert\":\" = true\\n\"},{\"insert\":\"> isPalindrome('toyota')\\n\"},{\"insert\":\" = false\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：case运行失败\\n\"},{\"insert\":\"2. 3.0分：case运行通过给\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","i18n_question_answer":"{\"0\":{\"ops\":[{\"insert\":\"\\n\"},{\"insert\":\"function isPalindrome(str){\\n\"},{\"insert\":\" var i, len = str.length;\\n\"},{\"insert\":\" for(i=0; i<len/2; i++){\\n\"},{\"insert\":\" if (str[i]!== str[len -1 -i])\\n\"},{\"insert\":\" return false;\\n\"},{\"insert\":\" }\\n\"},{\"insert\":\" return true;\\n\"},{\"insert\":\"}\\n\"},{\"insert\":\"> isPalindrome('madam')\\n\"},{\"insert\":\" = true\\n\"},{\"insert\":\"> isPalindrome('toyota')\\n\"},{\"insert\":\" = false\\n\"},{\"insert\":\"\\n\"},{\"insert\":\"1. 2.5分及以下：case运行失败\\n\"},{\"insert\":\"2. 3.0分：case运行通过给\\n\"}],\"zoneId\":\"0\",\"zoneType\":\"Z\"}}","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239917000228","question_title":"作用域以及变量提升","i18n_question_title":"作用域以及变量提升","question_skill_list":null,"score":null,"content":null,"question_description":"### 请写出下题的结果：\n```\nvar a = 1; \nfunction b() { \n    a = 10; \n    return; \n    function a() {} \n} \nb(); \nconsole.log(a);   \n```","i18n_question_description":"### 请写出下题的结果：\n```\nvar a = 1; \nfunction b() { \n    a = 10; \n    return; \n    function a() {} \n} \nb(); \nconsole.log(a);   \n```","question_answer":"结果：1\n1. 2.5分及以下：答案错误\n2. 3.0分：答案正确，并能回答出function声明的方法会在其作用域内提升执行。所以，在b函数内部，a=10优先访问本地声明的变量，全局变量a没有改变，所以结果是1。：","i18n_question_answer":"结果：1\n1. 2.5分及以下：答案错误\n2. 3.0分：答案正确，并能回答出function声明的方法会在其作用域内提升执行。所以，在b函数内部，a=10优先访问本地声明的变量，全局变量a没有改变，所以结果是1。：","status_end_time":null,"assessment_create_time":null}],"BaseResp":{"StatusMessage":"SUCCESS","StatusCode":0,"Extra":null}},"message":"OK","special_case_code":0}
