{"code":0,"success":true,"data":{"has_more":true,"page_token":"jG8alc3pzro5Kly/dRxpXE2T4GkGZIpgSywkP6hrEoU=","assessments_list":[{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916557860","question_title":"Vue框架中组件消息通信方式","i18n_question_title":"Vue框架中组件消息通信方式","question_skill_list":[{"name":"JavaScript","i18n_name":"JavaScript","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"考察候选人对Vue框架的消息通信方式了解程度：\n1. vue父子组件通信方式？\n2. 非父子组件通信方式？\n3. 前两问OK，追问：当一个父组件与子组件中间隔着很多层组件怎么办？","i18n_question_description":"考察候选人对Vue框架的消息通信方式了解程度：\n1. vue父子组件通信方式？\n2. 非父子组件通信方式？\n3. 前两问OK，追问：当一个父组件与子组件中间隔着很多层组件怎么办？","question_answer":"1. 父子组件通信方式\n在Vue中，父子组件的关系可以总结为props down, events up。父组件通过props向下传递数据给子组件，子组件通过events给父组件发送消息。\n2. 非父子组件通信\n两个独立的组件之间通信，可以借助一个空的Vue实例作为中央事件总线，空实例相当于代理人的形式进行消息监听或触发\n3. 父子之间层级过多时\n当父子组件之间层级不多的时候，父组件可以一层层的向子组件传递数据或者子组件一层层向父组件发送消息，代码上没有太难维护的地方。可是，一旦父子组件之间层级变多后，传递一个数据或者发送一个消息就变得麻烦。\n这块如果了解开源的Element组件库，就会知道其实现方式：构造一个函数自动向上/向下查询父亲节点，以`[组件名, 消息名, 参数]`三元组进行消息传递，降低长链传播成本;\n1. 2.5分及以下：不了解这个概念\n2. 3.0分：答出前两问\n3. 3.5分：3个问题都能答出\n4. 4.0分：","i18n_question_answer":"1. 父子组件通信方式\n在Vue中，父子组件的关系可以总结为props down, events up。父组件通过props向下传递数据给子组件，子组件通过events给父组件发送消息。\n2. 非父子组件通信\n两个独立的组件之间通信，可以借助一个空的Vue实例作为中央事件总线，空实例相当于代理人的形式进行消息监听或触发\n3. 父子之间层级过多时\n当父子组件之间层级不多的时候，父组件可以一层层的向子组件传递数据或者子组件一层层向父组件发送消息，代码上没有太难维护的地方。可是，一旦父子组件之间层级变多后，传递一个数据或者发送一个消息就变得麻烦。\n这块如果了解开源的Element组件库，就会知道其实现方式：构造一个函数自动向上/向下查询父亲节点，以`[组件名, 消息名, 参数]`三元组进行消息传递，降低长链传播成本;\n1. 2.5分及以下：不了解这个概念\n2. 3.0分：答出前两问\n3. 3.5分：3个问题都能答出\n4. 4.0分：","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058244135093767","question_title":"Https的连接过程？","i18n_question_title":"Https的连接过程？","question_skill_list":[{"name":"Web技术","i18n_name":"Web技术","nick_name":null,"description":null}],"score":null,"content":null,"question_description":null,"i18n_question_description":null,"question_answer":"客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）；\n服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）；\n客户端验证服务器的合法性，包括：证书是否过期，CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；\n如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个随机密钥（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行摘要计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器；\n服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器；\n浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密\n总结：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。","i18n_question_answer":"客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）；\n服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）；\n客户端验证服务器的合法性，包括：证书是否过期，CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；\n如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个随机密钥（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行摘要计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器；\n服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器；\n浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密\n总结：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402298935588","question_title":"请简述进程和线程的联系和区分\n 请回答一个进程中有哪些数据段？同一个进程下的不同线程间有哪些数据段可以共享访问？","i18n_question_title":"请简述进程和线程的联系和区分\n 请回答一个进程中有哪些数据段？同一个进程下的不同线程间有哪些数据段可以共享访问？","question_skill_list":[{"name":"进程管理","i18n_name":"进程管理","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"- 进程和线程有什么区别？\n  - 一个进程中有哪些数据段？同一个进程下的不同线程间有哪些数据段可以共享访问？","i18n_question_description":"- 进程和线程有什么区别？\n  - 一个进程中有哪些数据段？同一个进程下的不同线程间有哪些数据段可以共享访问？","question_answer":"- 区别和联系\n  - 线程是CPU调度的基本单位，同一个进程中可以有多个线程，但至少有一个线程\n  - 进程是操作系统分配资源的最小单位\n  - 一个进程中有哪些数据段\n  - 代码段（Text Segment）：保存代码\n  - 静态数据段（Data Segment）：静态数据\n  - 未初始化数据段（BSS）\n  - 栈（Stack）：向下增长\n  - 堆（Heap）：向上增长\n  - .rodata\n  - 同一个进程下的不同线程间有哪些数据段是共享的？\n  - 除Stack外均共享","i18n_question_answer":"- 区别和联系\n  - 线程是CPU调度的基本单位，同一个进程中可以有多个线程，但至少有一个线程\n  - 进程是操作系统分配资源的最小单位\n  - 一个进程中有哪些数据段\n  - 代码段（Text Segment）：保存代码\n  - 静态数据段（Data Segment）：静态数据\n  - 未初始化数据段（BSS）\n  - 栈（Stack）：向下增长\n  - 堆（Heap）：向上增长\n  - .rodata\n  - 同一个进程下的不同线程间有哪些数据段是共享的？\n  - 除Stack外均共享","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058228012828197","question_title":"什么是正向代理和反向代理？","i18n_question_title":"什么是正向代理和反向代理？","question_skill_list":[{"name":"网络运维","i18n_name":"网络运维","nick_name":null,"description":null}],"score":null,"content":null,"question_description":null,"i18n_question_description":null,"question_answer":"正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。","i18n_question_answer":"正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495290206587144","question_title":"TCP 四次挥手之后，为什么要等待2MLS超时时间？","i18n_question_title":"TCP 四次挥手之后，为什么要等待2MLS超时时间？","question_skill_list":[{"name":"数据库","i18n_name":"数据库","nick_name":null,"description":null},{"name":"MySQL","i18n_name":"MySQL","nick_name":null,"description":null}],"score":null,"content":null,"question_description":null,"i18n_question_description":null,"question_answer":null,"i18n_question_answer":null,"status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058255971960351","question_title":"WebGL光栅化过程中为什么会产生锯齿？","i18n_question_title":"WebGL光栅化过程中为什么会产生锯齿？","question_skill_list":[{"name":"可视化","i18n_name":"可视化","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"锯齿为什么会产生？\n抗锯齿有哪些手段","i18n_question_description":"锯齿为什么会产生？\n抗锯齿有哪些手段","question_answer":"锯齿为什么会产生？\n【3-】： 屏幕是用一个个像素展示的，所以就有锯齿。\n【3】图像是连续的，而屏幕是离散的，从而产生锯齿。\n【3+】在频域上，由于采样能力不足，信号变化快，采样速度跟不上，产生频谱堆叠，导致采样不准确，从而产生了Aliasing，有锯齿或摩尔纹、车轮效应等等表现。\n抗锯齿有哪些手段？\n1- Pre-Filtering \n先模糊（加一个滤波器）一下再采样。\n追问：为什么不可以先采样再模糊？\n原理：\n在频域上，通过低通滤波器，拿掉高频滤波，可以将堆叠的频谱部分进行一部分删减，从而消除频谱堆叠。如果先采样在模糊，实际上频谱堆叠并不会消失。\n2-MSAA mutilate sample antialiasing\nMSAA是WebGL中的默认抗锯齿方法，通过对一个像素内部增大采样点，近似达到合理的分辨率，根据采样点的情况，进行颜色插值从而完成抗锯齿。\n3- 其他方案\nFXAA (Fast Approximate AA) 快速近似抗锯齿 \nTAA （Temporal AA）时间序列抗锯齿\n抗锯齿有哪些手段？\n3： 能知道Pre-Filtering 和MSAA的方法来抗锯齿\n3+： 能知道Pre-Filtering、MSAA的原理\n3.5： 在3+的基础上，还知道 FXAA\\TAA 等抗锯齿方法","i18n_question_answer":"锯齿为什么会产生？\n【3-】： 屏幕是用一个个像素展示的，所以就有锯齿。\n【3】图像是连续的，而屏幕是离散的，从而产生锯齿。\n【3+】在频域上，由于采样能力不足，信号变化快，采样速度跟不上，产生频谱堆叠，导致采样不准确，从而产生了Aliasing，有锯齿或摩尔纹、车轮效应等等表现。\n抗锯齿有哪些手段？\n1- Pre-Filtering \n先模糊（加一个滤波器）一下再采样。\n追问：为什么不可以先采样再模糊？\n原理：\n在频域上，通过低通滤波器，拿掉高频滤波，可以将堆叠的频谱部分进行一部分删减，从而消除频谱堆叠。如果先采样在模糊，实际上频谱堆叠并不会消失。\n2-MSAA mutilate sample antialiasing\nMSAA是WebGL中的默认抗锯齿方法，通过对一个像素内部增大采样点，近似达到合理的分辨率，根据采样点的情况，进行颜色插值从而完成抗锯齿。\n3- 其他方案\nFXAA (Fast Approximate AA) 快速近似抗锯齿 \nTAA （Temporal AA）时间序列抗锯齿\n抗锯齿有哪些手段？\n3： 能知道Pre-Filtering 和MSAA的方法来抗锯齿\n3+： 能知道Pre-Filtering、MSAA的原理\n3.5： 在3+的基础上，还知道 FXAA\\TAA 等抗锯齿方法","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402307815693","question_title":"请简述CSS中position:absolute作用","i18n_question_title":"请简述CSS中position:absolute作用","question_skill_list":[{"name":"CSS","i18n_name":"CSS","nick_name":null,"description":null},{"name":"语言基础","i18n_name":"语言基础","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"* 考察CSS中position:absolute作用；\n  * 了解该属性作用后，再接着问：absolute元素会相对设置`position: fixed`的元素定位吗？","i18n_question_description":"* 考察CSS中position:absolute作用；\n  * 了解该属性作用后，再接着问：absolute元素会相对设置`position: fixed`的元素定位吗？","question_answer":"设置postion: absolute;的元素会相对于值不为 static的第一个父元素进行定位","i18n_question_answer":"设置postion: absolute;的元素会相对于值不为 static的第一个父元素进行定位","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402307995917","question_title":"请介绍一下 MVVM 框架，如 Angular、React、Vue，并简述它们都解决了什么问题？","i18n_question_title":"请介绍一下 MVVM 框架，如 Angular、React、Vue，并简述它们都解决了什么问题？","question_skill_list":[{"name":"框架相关","i18n_name":"框架相关","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"如题，就是介绍一下对框架的了解","i18n_question_description":"如题，就是介绍一下对框架的了解","question_answer":"这道题目可深可浅，主要是考察面试者对于技术选型上的一个思考，没有对错的一道题目，但是应该可以面出来经验。\n  比如 Angular 这个框架的设计实际上是很好的，但是由于它想解决太多事情，反而有些累赘，再加上性能上并非最优，所以被后起之秀赶超。\n  React 我的理解就是一个模板引擎，但是支持 JSX 的写法，不是一般的模板写法，另外 flux 的思想及 Rudex 的实现，使之也可以解决大的系统问题。\n  而且 React 能够结合 React Native 使技术在写法及框架思路上得到一个统一。\n  Vue 小巧而且很使用，还不是 JSX 的写法，没有摒弃掉 Web 的传统开发方式，也可以通过使用 Vuex 来解决系统性问题。\n  总之，这道题没有一个标准答案，可以和面试者各种聊。","i18n_question_answer":"这道题目可深可浅，主要是考察面试者对于技术选型上的一个思考，没有对错的一道题目，但是应该可以面出来经验。\n  比如 Angular 这个框架的设计实际上是很好的，但是由于它想解决太多事情，反而有些累赘，再加上性能上并非最优，所以被后起之秀赶超。\n  React 我的理解就是一个模板引擎，但是支持 JSX 的写法，不是一般的模板写法，另外 flux 的思想及 Rudex 的实现，使之也可以解决大的系统问题。\n  而且 React 能够结合 React Native 使技术在写法及框架思路上得到一个统一。\n  Vue 小巧而且很使用，还不是 JSX 的写法，没有摒弃掉 Web 的传统开发方式，也可以通过使用 Vuex 来解决系统性问题。\n  总之，这道题没有一个标准答案，可以和面试者各种聊。","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"6960495402308159757","question_title":"请谈谈CSS3中2d变化和3d变化有什么区别，他们之间的性能对比如何，是否用到了gpu加速？","i18n_question_title":"请谈谈CSS3中2d变化和3d变化有什么区别，他们之间的性能对比如何，是否用到了gpu加速？","question_skill_list":[{"name":"CSS3","i18n_name":"CSS3","nick_name":null,"description":null},{"name":"动画","i18n_name":"动画","nick_name":null,"description":null}],"score":null,"content":null,"question_description":"CSS3中2d变化和3d变化有什么区别，性能对比如何，是否用到了gpu加速？","i18n_question_description":"CSS3中2d变化和3d变化有什么区别，性能对比如何，是否用到了gpu加速？","question_answer":"1. 对于translate和scale，2d变换时有两条轴，对于rotate，2d变化时只有一条轴。3d变化时，都存在相对x、y、z轴的变化。\n  2. 2d和3d变化都用到了gpu，因为gpu擅长图像的变化操作\n  3. 3d变化性能更好，虽然2d和3d都用到了gpu，但是2d变换的元素只有在动画过程中才会提到复合层（composite layer），而3d变换的元素一开始就被提到了符合层。","i18n_question_answer":"1. 对于translate和scale，2d变换时有两条轴，对于rotate，2d变化时只有一条轴。3d变化时，都存在相对x、y、z轴的变化。\n  2. 2d和3d变化都用到了gpu，因为gpu擅长图像的变化操作\n  3. 3d变化性能更好，虽然2d和3d都用到了gpu，但是2d变换的元素只有在动画过程中才会提到复合层（composite layer），而3d变换的元素一开始就被提到了符合层。","status_end_time":null,"assessment_create_time":null},{"id":null,"assessment_status":1,"target_id":"7073761953432652039","target_type":1,"minutes":null,"question_id":"7021058239916066340","question_title":"绘制二叉树","i18n_question_title":"绘制二叉树","question_skill_list":null,"score":null,"content":null,"question_description":"给你一棵二叉树, 打印出如下的格式:\nt\n**l\n****l.l\n****l.r\n**r\n****r.l\n****r.r","i18n_question_description":"给你一棵二叉树, 打印出如下的格式:\nt\n**l\n****l.l\n****l.r\n**r\n****r.l\n****r.r","question_answer":"使用dfs 记录当前节点树的高度\n比较简单\n能写出正确代码","i18n_question_answer":"使用dfs 记录当前节点树的高度\n比较简单\n能写出正确代码","status_end_time":null,"assessment_create_time":null}],"BaseResp":{"StatusMessage":"SUCCESS","StatusCode":0,"Extra":null}},"message":"OK","special_case_code":0}
